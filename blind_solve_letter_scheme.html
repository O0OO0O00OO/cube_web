<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LETTER SCHEME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background-color: black;
      color: white;
      font-family: sans-serif;
    }

    .center-wrap{
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;

      padding-bottom: var(--vk-height);
      box-sizing: border-box;
    }


    h1 {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 24px;
    }

    a.back-link {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      text-decoration: none;
      font-size: 16px;
    }

    .cube-box{
      width: min(60vmin, 300px);
      height: min(60vmin, 300px);
      /* transform: translateY(-60px);  刪掉 */
    }


    .panel {
      position: absolute;
      right: 14px;
      top: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 12px;
      backdrop-filter: blur(6px);
      z-index: 10;
    }
    .panel h2 {
      margin: 0 0 8px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .5px;
      opacity: .9;
    }
    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 6px; }
    select, button {
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    button.primary { border-color: rgba(255,255,255,0.28); }

    select {
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    select option {
      background: #111;
      color: white;
    }
    select option:hover,
    select option:checked {
      background: #333;
      color: white;
    }

    .panel input[type="checkbox"]{
      width: 14px;
      height: 14px;
      accent-color: #58ffa7;
    }

    .key-flash {
      position: absolute;
      bottom: calc(var(--vk-height) + 24px);
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 50px;
      font-weight: 700;
      letter-spacing: 1px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.16);
      color: white;
      opacity: 0;
      transition: opacity .12s ease;
      pointer-events: none;
      z-index: 9;
    }
    .key-flash.show { opacity: 1; }
    .key-flash.ok  { box-shadow: 0 0 16px rgba(0,255,128,.35); color: #33df27; }
    .key-flash.bad { box-shadow: 0 0 16px rgba(255,64,64,.35); color: #FF7C7C; }

    .progress {
      position: relative;
      height: 8px;
      width: 210px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 999px;
      overflow: hidden;
    }
    .progress-bar {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 0%;
      background: linear-gradient(90deg, #58ffa7, #4dc4ff);
      transition: width .18s ease;
    }
    #pbEdges, #pbCorners, #pbAll { font-weight: 700; }

    .br-text{
      position: absolute;
      left: 14px;                 /* 改左邊 */
      right: auto;                /* 關鍵：取消 right */
      bottom: calc(var(--vk-height) + 14px);
      padding: 10px 12px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      font-size: 24px;
      line-height: 1.4;
      white-space: pre-wrap;
      z-index: 1;
    }


    #memoryModal button {
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    #memoryModal button.primary { border-color: rgba(255,255,255,0.28); }
    :root{
      --vk-height: 260px;
    }

    /* =========================
       Mobile A-Z pad
       ========================= */
    #mobilePad {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px 10px calc(10px + env(safe-area-inset-bottom));
      background: rgba(0,0,0,0.75);
      border-top: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(8px);
      z-index: 9998;

      display: block; /* JS will toggle */
      user-select: none;
      touch-action: manipulation;
    }
    #mobilePad .vk{
      display:flex;
      flex-direction:column;
      gap:10px;
      max-width: 720px;
      margin: 0 auto;
    }
    #mobilePad .row{
      display: flex;
      gap: 6px;
      justify-content: center;  /* 置中即可 */
    }


    #mobilePad button.key.wide{
      width: 88px;
    }
    #mobilePad button.key{
      flex: 0 0 auto;
      width: 40px;
      height: 48px;
      padding: 0;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 800;
      letter-spacing: 1px;
      background: rgba(255,255,255,0.08);
      color: white;
      border: 1px solid rgba(255,255,255,0.18);
      cursor: pointer;
    }
    #mobilePad button.key.wide{ width: 88px; }
    #mobilePad button.key:active{
      background: rgba(255,255,255,0.14);
      border-color: rgba(255,255,255,0.28);
    }


    #mobilePad{
      height: var(--vk-height);
      padding: 10px 10px calc(10px + env(safe-area-inset-bottom));
      box-sizing: border-box;
    }
/* 觸控裝置一律用滿版鍵盤（手機/平板） */
@media (pointer: coarse) {
  #mobilePad {
    padding-left: 8px;
    padding-right: 8px; 
    bottom: 18px !important; /* 往上提 */
  }

  /* 讓鍵盤容器吃滿寬度，不再 720px 置中 */
  #mobilePad .vk{
    max-width: none !important;
    width: 100% !important;
    margin: 0 !important;
  }

  /* 每列吃滿 */
  #mobilePad .row{
    width: 100%;
    justify-content: stretch !important;
  }

  /* 一般鍵：等分整列寬度 */
  #mobilePad button.key{
    flex: 1 1 0 !important;
    width: auto !important;
    height: 108px;
    font-size: 36px;
    padding: 0;
  }

  /* 寬鍵：給比例，別用固定 px */
  #mobilePad button.key.wide{
    flex: 1.6 1 0 !important;
    width: auto !important;
  }
}


  </style>
</head>

<body>
  <div class="center-wrap">
    <a class="back-link" href="index.html">← Back to Home</a>
    <h1>BLIND SOLVE LETTER SCHEME</h1>

    <div class="cube-box">
      <twisty-player
        id="twisty"
        puzzle="3x3x3"
        background="none"
        alg=""
        control-panel="none"
        hint-facelets="none"
        camera-latitude-limit="90"
        experimental-drag-input="none"
        style="width:100%; height:100%;"
        camera-latitude="60"
        camera-longitude="45"
        experimental-stickering-mask-orbits="EDGES:IIIIIIIIIIII,CORNERS:IIIIIIII,CENTERS:IIIIII"
      ></twisty-player>
    </div>

    <div id="keyFlash" class="key-flash"></div>

    <div class="panel" id="panel">
      <h2>BLD Trainer</h2>

      <div class="row">
        <label for="mode">Mode</label>
        <select id="mode">
          <option value="edges" selected>Edges</option>
          <option value="corners">Corners</option>
          <option value="all">Edges + Corners</option>
        </select>
      </div>

      <div class="row">
        <label for="scheme">Letter Scheme</label>
        <select id="scheme">
          <option value="custom" selected>Speffz</option>
        </select>
      </div>

      <div class="row">
        <label for="memory">Memory</label>
        <input type="checkbox" id="memory" />
      </div>

      <div class="row">
        <button id="start" class="primary">Start / Reset</button>
      </div>

      <div class="row">
        <div style="opacity:.85; font-weight:700;">Time</div>
        <div id="timer" style="margin-left:8px;">00:00.00</div>
      </div>

      <div class="row" style="flex-direction:column; align-items:flex-start;">
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <div>Edges: <span id="pbEdges">--:--.--</span></div>
          <div>Corners: <span id="pbCorners">--:--.--</span></div>
          <div>All: <span id="pbAll">--:--.--</span></div>
        </div>
      </div>

      <div class="row" style="align-items:center; gap:10px;">
        <div class="progress" style="flex:1;">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div id="progressText" style="min-width:64px; text-align:right;">0/0</div>
      </div>
    </div>

    <div class="br-text">
      <span style="color: #ffffff;">A</span><span style="color: #0000ff;">Q</span>    <span style="color: #00ff00;">K</span><span style="color: #ffff00;">U</span>    <span style="color: #ff8800;">F</span><span style="color: #00ff00;">L</span>
      <span style="color: #ffffff;">B</span><span style="color: #ff0000;">M</span>    <span style="color: #ff0000;">O</span><span style="color: #ffff00;">V</span>    <span style="color: #0000ff;">R</span><span style="color: #ff8800;">H</span>
      <span style="color: #ffffff;">C</span><span style="color: #00ff00;">I</span>     <span style="color: #0000ff;">S</span><span style="color: #ffff00;">W</span>    <span style="color: #0000ff;">T</span><span style="color: #ff0000;">N</span>
      <span style="color: #ffffff;">D</span><span style="color: #ff8800;">E</span>    <span style="color: #ff8800;">G</span><span style="color: #ffff00;">X</span>    <span style="color: #00ff00;">J</span><span style="color: #ff0000;">P</span>

      <span style="color: #ffffff;">A</span><span style="color: #0000ff;">R</span><span style="color: #ff8800;">E</span>  <span style="color: #ffffff;">B</span><span style="color: #ff0000;">N</span><span style="color: #0000ff;">Q</span>
      <span style="color: #00ff00;">I</span><span style="color: #ffffff;">D</span><span style="color: #ff8800;">F</span>   <span style="color: #ff0000;">M</span><span style="color: #00ff00;">J</span><span style="color: #ffffff;">C</span>
      <span style="color: #0000ff;">S</span><span style="color: #ff8800;">H</span><span style="color: #ffff00;">X</span>  <span style="color: #0000ff;">T</span><span style="color: #ff0000;">O</span><span style="color: #ffff00;">W</span>
      <span style="color: #ff8800;">G</span><span style="color: #ffff00;">U</span><span style="color: #00ff00;">L</span>  <span style="color: #00ff00;">K</span><span style="color: #ff0000;">P</span><span style="color: #ffff00;">V</span>
    </div>
  </div>

  <!-- Mobile pad -->
  <div id="mobilePad" aria-hidden="false">
    <div class="vk" id="mobileGrid"></div>
  </div>


  <!-- Memory Modal -->
  <div id="memoryModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.65); backdrop-filter: blur(6px); z-index:9999;">
    <div style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:min(520px, 92vw);
                background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.16); border-radius:14px; padding:16px;">
      <div style="font-weight:800; letter-spacing:.5px; margin-bottom:10px;">Memory Recall</div>
      <div style="opacity:.85; margin-bottom:10px; line-height:1.35;">
        請輸入這一輪的作答字母序列（可含空白），正確才會停表。<br/>
        按 Cancel 視為沒有 memory（用 normal PB 記錄）。
      </div>

      <input id="memoryInput" type="text"
             style="width:100%; box-sizing:border-box; padding:10px 12px; border-radius:10px;
                    background:rgba(0,0,0,.35); color:white; border:1px solid rgba(255,255,255,0.18);
                    font-size:16px; letter-spacing:2px;"
             autocomplete="off" spellcheck="false" />

      <div id="memoryHint" style="margin-top:10px; min-height:18px; font-weight:700;"></div>

      <div style="display:flex; gap:10px; margin-top:12px; justify-content:flex-end;">
        <button id="memoryCancel">Cancel</button>
        <button id="memorySubmit" class="primary">Submit</button>
      </div>
    </div>
  </div>

  <script type="module" src="https://cdn.cubing.net/v0/js/cubing/twisty"></script>
  <script type="module">
  import { BLIND_ORDER as ORDER, BLIND_SCHEME as SCHEME } from './algorithms.js';
    document.addEventListener("keydown", function (e) {
      if (e.key === "Escape") window.location.href = "index.html";
    });

    const ui = {
      mode:   document.getElementById('mode'),
      scheme: document.getElementById('scheme'),
      memory: document.getElementById('memory'),
      start:  document.getElementById('start'),
    };

    document.addEventListener('keydown', (e) => {
      if (e.key === ' ') {
        if (isMemoryModalOpen()) return;
        e.preventDefault();
        ui.start.click();
      }
    });

    const twisty   = document.getElementById("twisty");
    const keyFlash = document.getElementById('keyFlash');
    const progressBar  = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');

    function stickerFacesOf(pos){
      return Object.keys(
        (SCHEME.edges[pos]?.stickers) || (SCHEME.corners[pos]?.stickers) || {}
      );
    }

    function makeMask(mode, index) {
      if (mode === "edges") {
        const arr = new Array(12).fill("I");
        arr[index] = "-";
        return `EDGES:${arr.join("")},CORNERS:IIIIIIII,CENTERS:IIIIII`;
      } else {
        const arr = new Array(8).fill("I");
        arr[index] = "-";
        return `EDGES:IIIIIIIIIIII,CORNERS:${arr.join("")},CENTERS:IIIIII`;
      }
    }

    let current = { mode: "edges", index: 0, pos: null, face: null };

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function buildDeck(mode){
      const deck = [];

      function pushTargets(_mode){
        for (const pos of ORDER[_mode]) {
          const faces = stickerFacesOf(pos);
          const face = faces[Math.floor(Math.random() * faces.length)];
          deck.push({ mode: _mode, pos, face });
        }
      }

      if (mode === "all") {
        pushTargets("edges");
        pushTargets("corners");
      } else {
        pushTargets(mode);
      }

      return shuffle(deck);
    }

    const deckState = { mode: "edges", deck: [], cursor: 0 };

    function setCurrentFromDeck(){
      const card = deckState.deck[deckState.cursor];
      current.mode  = card.mode;
      current.pos   = card.pos;
      current.face  = card.face;
      current.index = ORDER[current.mode].indexOf(current.pos);
    }

    function renderCurrent() {
      twisty.setAttribute("experimental-stickering-mask-orbits", makeMask(current.mode, current.index));
      twisty.setAttribute("camera-longitude", current.mode === "edges" ? "0" : "45");
      const info = SCHEME[current.mode][current.pos].stickers[current.face];
      twisty.setAttribute("alg", info.setup || "");
    }

    function updateProgressUI() {
      const total = deckState.deck.length || 0;
      const done  = Math.min(deckState.cursor, total);
      const pct   = total ? Math.round((done / total) * 100) : 0;
      progressBar.style.width = pct + '%';
      progressText.textContent = `${done}/${total}`;
    }

    const timerEl = document.getElementById('timer');
    let timer = null;
    let startTime = 0;

    function fmtTime(ms){
      const cs = Math.floor(ms / 10) % 100;
      const s  = Math.floor(ms / 1000) % 60;
      const m  = Math.floor(ms / 60000);
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
    }
    function updateTimer(){
      const ms = Date.now() - startTime;
      if (timerEl) timerEl.textContent = fmtTime(ms);
    }
    function startTimer(){
      stopTimer();
      startTime = Date.now();
      timer = setInterval(updateTimer, 31);
      updateTimer();
    }
    function stopTimer(){
      if (timer){ clearInterval(timer); timer = null; }
    }

    const pbEl = {
      edges:   document.getElementById('pbEdges'),
      corners: document.getElementById('pbCorners'),
      all:     document.getElementById('pbAll'),
    };

    const PB_KEY = 'bldTrainerPB.v2';
    let PB = {
      normal: { edges: null, corners: null, all: null },
      memory: { edges: null, corners: null, all: null },
    };

    function fmtPB(ms){
      if (ms == null) return '--:--.--';
      const cs = Math.floor(ms / 10) % 100;
      const s  = Math.floor(ms / 1000) % 60;
      const m  = Math.floor(ms / 60000);
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
    }

    function getPBSet(){
      return ui.memory?.checked ? 'memory' : 'normal';
    }

    function updatePBUI(){
      const set = getPBSet();
      if (pbEl.edges)   pbEl.edges.textContent   = fmtPB(PB[set].edges);
      if (pbEl.corners) pbEl.corners.textContent = fmtPB(PB[set].corners);
      if (pbEl.all)     pbEl.all.textContent     = fmtPB(PB[set].all);
    }

    function loadPB(){
      try {
        const raw = localStorage.getItem(PB_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          PB.normal = { ...PB.normal, ...(parsed.normal || {}) };
          PB.memory = { ...PB.memory, ...(parsed.memory || {}) };
        }
      } catch(_) {}
      updatePBUI();
    }
    function savePB(){
      try { localStorage.setItem(PB_KEY, JSON.stringify(PB)); } catch(_) {}
    }

    function maybeUpdatePB(mode, elapsedMs, forceSet /* 'normal' | 'memory' | null */ = null){
      if (elapsedMs == null) return;
      const set = forceSet || getPBSet();
      if (PB[set][mode] == null || elapsedMs < PB[set][mode]) {
        PB[set][mode] = elapsedMs;
        savePB();
        updatePBUI();
      }
    }

    if (ui.memory) ui.memory.addEventListener('change', updatePBUI);

    const memoryModal  = document.getElementById('memoryModal');
    const memoryInput  = document.getElementById('memoryInput');
    const memorySubmit = document.getElementById('memorySubmit');
    const memoryCancel = document.getElementById('memoryCancel');
    const memoryHint   = document.getElementById('memoryHint');

    let roundAnswers = [];
    let memoryWaiting = false;

    function isMemoryModalOpen(){
      return memoryModal && memoryModal.style.display !== 'none';
    }

    function normalizeRecall(s){
      return (s || '').toUpperCase().replace(/[^A-Z]/g, '');
    }

    function openMemoryModal(){
      if (!memoryModal) return;
      memoryWaiting = true;
      memoryHint.textContent = '';
      memoryHint.style.color = 'white';
      memoryInput.value = '';
      memoryModal.style.display = 'block';
      setTimeout(() => memoryInput.focus(), 0);
    }

    function closeMemoryModal(){
      if (!memoryModal) return;
      memoryModal.style.display = 'none';
    }

    function finalizeAsNormalFromMemory(){
      const elapsed = Date.now() - startTime;
      stopTimer();
      maybeUpdatePB(deckState.mode, elapsed, 'normal');

      memoryWaiting = false;
      closeMemoryModal();
    }

    function submitMemoryRecall(){
      if (!memoryWaiting) return;

      const expected = roundAnswers.join('');
      const got = normalizeRecall(memoryInput.value);

      if (got === expected) {
        memoryHint.textContent = 'Correct';
        memoryHint.style.color = '#58ffa7';

        const elapsed = Date.now() - startTime;
        stopTimer();

        maybeUpdatePB(deckState.mode, elapsed, 'memory');

        memoryWaiting = false;
        closeMemoryModal();
        return;
      }

      memoryHint.textContent = `Wrong (${got.length}/${expected.length})`;
      memoryHint.style.color = '#FF7C7C';
      memoryInput.select();
      memoryInput.focus();
    }

    if (memorySubmit) memorySubmit.addEventListener('click', submitMemoryRecall);
    if (memoryCancel) memoryCancel.addEventListener('click', finalizeAsNormalFromMemory);

    if (memoryInput) {
      memoryInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') submitMemoryRecall();
        if (e.key === 'Escape') {
          e.preventDefault();
          finalizeAsNormalFromMemory();
        }
      });
    }

    function showKeyFlash(text, cls) {
      keyFlash.textContent = text;
      keyFlash.classList.remove('ok', 'bad');
      if (cls) keyFlash.classList.add(cls);
      keyFlash.classList.add('show');
    }
    function hideKeyFlash() {
      keyFlash.classList.remove('show', 'ok', 'bad');
      keyFlash.textContent = '';
    }

    function nextCard(){
      deckState.cursor++;
      const total = deckState.deck.length;

      if (deckState.cursor >= total) {
        updateProgressUI();

        if (!ui.memory.checked) {
          stopTimer();
          const elapsed = Date.now() - startTime;
          maybeUpdatePB(deckState.mode, elapsed, 'normal');
          return;
        }

        openMemoryModal();
        return;
      }

      setCurrentFromDeck();
      renderCurrent();
      updateProgressUI();
    }

    ui.start.addEventListener('click', () => {
      if (isMemoryModalOpen()) {
        closeMemoryModal();
        memoryWaiting = false;
      }

      deckState.mode   = ui.mode.value;
      deckState.deck   = buildDeck(deckState.mode);
      deckState.cursor = 0;

      roundAnswers = [];

      setCurrentFromDeck();
      renderCurrent();
      updateProgressUI();

      startTimer();
    });

    window.addEventListener("load", () => {
      loadPB();

      ui.mode.value = "edges";

      deckState.mode   = ui.mode.value;
      deckState.deck   = buildDeck(deckState.mode);
      deckState.cursor = 0;

      roundAnswers = [];
      memoryWaiting = false;
      closeMemoryModal();

      setCurrentFromDeck();
      renderCurrent();
      updateProgressUI();

      if (timerEl) timerEl.textContent = "00:00.00";

      // init mobile pad state
      initMobilePad();
    });

    const keyState = {
      lastKey: null,
      shouldAdvanceOnRelease: false,
    };

    function handleLetterDown(key /* 'A'..'Z' */){
      if (isMemoryModalOpen()) return;
      if (!/^[A-Z]$/.test(key)) return;
      if (keyState.lastKey === key) return;

      keyState.lastKey = key;

      const info = SCHEME[current.mode]?.[current.pos]?.stickers?.[current.face];
      const ans = (info?.letter || "").toUpperCase();

      if (!ans) {
        showKeyFlash(key);
        keyState.shouldAdvanceOnRelease = false;
        return;
      }

      if (key === ans) {
        showKeyFlash(key, 'ok');
        keyState.shouldAdvanceOnRelease = true;
      } else {
        showKeyFlash(key, 'bad');
        keyState.shouldAdvanceOnRelease = false;
      }
    }

    function handleLetterUp(key /* 'A'..'Z' */){
      if (isMemoryModalOpen()) return;
      if (!/^[A-Z]$/.test(key)) return;
      if (key !== keyState.lastKey) return;

      hideKeyFlash();

      if (keyState.shouldAdvanceOnRelease) {
        const info = SCHEME[current.mode]?.[current.pos]?.stickers?.[current.face];
        const ans  = (info?.letter || "").toUpperCase();
        if (ans) roundAnswers.push(ans);

        nextCard();
      }

      keyState.lastKey = null;
      keyState.shouldAdvanceOnRelease = false;
    }

    // Desktop keyboard -> reuse same handlers
    document.addEventListener('keydown', (e) => {
      if (isMemoryModalOpen()) return;
      if (e.key === "Escape") return;

      const key = e.key.toUpperCase();
      if (!/^[A-Z]$/.test(key)) return;

      // prevent repeat from holding key
      if (e.repeat) return;

      handleLetterDown(key);
    });

    document.addEventListener('keyup', (e) => {
      if (isMemoryModalOpen()) return;

      const key = e.key.toUpperCase();
      if (!/^[A-Z]$/.test(key)) return;

      handleLetterUp(key);
    });

    /* =========================
       Mobile pad implementation
       ========================= */
    const mobilePad  = document.getElementById('mobilePad');
    const mobileGrid = document.getElementById('mobileGrid');



    function setMobilePadVisible(v){
      if (!mobilePad) return;
      mobilePad.style.display = 'block';
      mobilePad.setAttribute('aria-hidden', 'false');
    }


    function buildMobileKeys(){
      if (!mobileGrid) return;

      mobileGrid.innerHTML = '';

      const rows = [
        ["Q","W","E","R","T","Y","U","I","O","P"],
        ["A","S","D","F","G","H","J","K","L"],
        ["Z","X","C","V","B","N","M"],
      ];

      function makeBtn(label, cls = ''){
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = `key ${cls}`.trim();
        btn.textContent = label;
        return btn;
      }

      // letter button behavior: pointerdown = down, pointerup = up
      function wireLetter(btn, ch){
        btn.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          handleLetterDown(ch);
        });
        btn.addEventListener('pointerup', (e) => {
          e.preventDefault();
          handleLetterUp(ch);
        });
        btn.addEventListener('pointercancel', (e) => {
          e.preventDefault();
          if (keyState.lastKey === ch) {
            hideKeyFlash();
            keyState.lastKey = null;
            keyState.shouldAdvanceOnRelease = false;
          }
        });
      }

      // Row 1
      {
        const r = document.createElement('div');
        r.className = 'row';
        rows[0].forEach(ch => {
          const b = makeBtn(ch);
          wireLetter(b, ch);
          r.appendChild(b);
        });
        mobileGrid.appendChild(r);
      }

      // Row 2
      {
        const r = document.createElement('div');
        r.className = 'row';
        rows[1].forEach(ch => {
          const b = makeBtn(ch);
          wireLetter(b, ch);
          r.appendChild(b);
        });
        mobileGrid.appendChild(r);
      }

      // Row 3 with Backspace / Enter
      {
        const r = document.createElement('div');
        r.className = 'row';

        const back = makeBtn('⌫', 'wide');
        back.addEventListener('click', (e) => {
          e.preventDefault();
          // cancel current press state (does not remove recorded answers)
          hideKeyFlash();
          keyState.lastKey = null;
          keyState.shouldAdvanceOnRelease = false;
        });

        const enter = makeBtn('Enter', 'wide');
        enter.addEventListener('click', (e) => {
          e.preventDefault();
          // no-op by default; keep for future (e.g. memory modal)
        });

        r.appendChild(back);

        rows[2].forEach(ch => {
          const b = makeBtn(ch);
          wireLetter(b, ch);
          r.appendChild(b);
        });

        r.appendChild(enter);

        mobileGrid.appendChild(r);
      }
    }

    function initMobilePad(){
      buildMobileKeys();
      setMobilePadVisible(true);
    }

  </script>
</body>
</html>
