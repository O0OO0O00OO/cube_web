<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SCRAMBLE</title>

  <style>
    body{
      background:black;
      color:white;
      font-family:sans-serif;
      margin:0;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    h1{ position:absolute; top:20px; margin:0; }
    a.back{
      position:absolute;
      top:20px; left:20px;
      color:white; text-decoration:none; font-size:16px;
    }

    /* Scramble row */
    #scramble-row{
      display:flex;
      align-items:center;
      gap:12px;
      margin-bottom:18px;
      max-width:92vw;
      width:92vw;
      justify-content:center;
      flex-wrap:wrap;
    }

    /* Editable scramble */
    #scramble-editor{
      font-size:22px;
      color:#aaa;
      max-width:70vw;
      width:min(760px, 70vw);
      text-align:center;
      word-break:break-word;
      line-height:1.4;
      outline:none;

      padding:10px 12px;
      border:1px solid #222;
      border-radius:10px;
      background:#0b0b0b;
      cursor:text;
      user-select:text;
    }
    #scramble-editor:focus{
      border-color:#444;
      box-shadow:0 0 0 2px rgba(255,255,255,0.06);
    }

    /* Scramble tools */
    #scramble-tools{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .tool-btn{
      padding:10px 14px;
      font-size:16px;
      background:#222;
      color:white;
      border:none;
      border-radius:8px;
      cursor:pointer;
      white-space:nowrap;
    }
    .tool-btn:hover{ background:#333; }
    .tool-btn:disabled{
      opacity:0.55;
      cursor:not-allowed;
    }

    #scramble-hint{
      margin-top:6px;
      font-size:12px;
      color:#666;
      text-align:center;
      max-width:92vw;
    }

    twisty-player{ width:280px; height:280px; }

    /* Track container */
    #track{
      margin-top:16px;
      color:#fff;
      font-weight:700;
      letter-spacing:2px;
      text-align:center;
      max-width:92vw;
      word-break:break-word;
      line-height:1.2;
    }

    .section{
      margin-top:10px;
    }
    .section-head{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .section-btn{
      font-size:32px;
      padding:8px 14px;
      background:#111;
      color:#fff;
      border:1px solid #333;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      touch-action:manipulation;
    }
    .section-btn:hover{ background:#171717; }

    .section-check{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:16px;
      color:#ddd;
      user-select:none;
    }
    .section-check input{
      width:18px;
      height:18px;
      cursor:pointer;
    }

    /* Key fix: keep layout stable while hiding */
    .track-letters{
      font-size:44px;
      line-height:1.2;
      max-width:92vw;
      margin:0 auto;

      display:block;            /* always occupies space */
      visibility:hidden;        /* hidden but keeps space */
      opacity:0;
      pointer-events:none;
      transition: opacity 80ms linear;
    }
    .track-letters.show{
      visibility:visible;
      opacity:1;
    }

    .spacer{ height:18px; }
  </style>

  <script type="module">
    import "https://cdn.cubing.net/v0/js/cubing/twisty";
    import { randomScrambleForEvent } from "https://cdn.cubing.net/v0/js/cubing/scramble";
    window.randomScrambleForEvent = randomScrambleForEvent;
  </script>
</head>

<body>
  <h1>SCRAMBLE</h1>
  <a href="index.html" class="back">‚Üê Back to Home</a>

  <!-- Scramble editor + tools -->
  <div id="scramble-row">
    <div id="scramble-editor" contenteditable="true" spellcheck="false"></div>
    <div id="scramble-tools">
      <button class="tool-btn" id="btn-new">New</button>
      <button class="tool-btn" id="btn-copy">Copy</button>
      <button class="tool-btn" id="btn-clear">Clear</button>
      <button class="tool-btn" id="btn-apply">Apply</button>
    </div>
  </div>
  <div id="scramble-hint">Edit the scramble then press Apply (WCA-style random-state 3x3 scramble, generator moves only).</div>

  <twisty-player
    id="twisty"
    puzzle="3x3x3"
    hint-facelets="floating"
    background="none"
    control-panel="none"
  ></twisty-player>

  <div id="track"></div>

<script>
  // =========================
  // DOM
  // =========================
  const $ = (id) => document.getElementById(id);

  // =========================
  // Scramble helpers
  // =========================
  function normalizeScrambleText(s){
    return (s || "").trim().replace(/\s+/g, " ");
  }

  function isValidGeneratorScramble(s){
    const t = normalizeScrambleText(s);
    if (!t) return false;
    const tokens = t.split(" ");
    const re = /^[RLUDFB](2|')?$/;
    return tokens.every(tok => re.test(tok));
  }

  function getScrambleFromEditor(){
    return normalizeScrambleText($("scramble-editor").textContent);
  }

  function setEditorScramble(s){
    $("scramble-editor").textContent = s;
  }

  // =========================
  // WCA-style random-state scramble (cubing.js)
  // =========================
  async function generateScrambleWCA333() {
    // randomScrambleForEvent("333") returns a Promise<Alg>
    const alg = await window.randomScrambleForEvent("333");
    return alg.toString();
  }

  // =========================
  // Track renderer
  // =========================
  function renderTrackHTML(cycles) {
    const colors = [
      "#ffd166", "#06d6a0", "#4cc9f0", "#f72585",
      "#b8f2e6", "#fca311", "#a78bfa", "#80ed99",
    ];

    const flat = [];
    cycles.forEach((letters, ci) => {
      letters.forEach(ch => flat.push({ ch, ci }));
    });

    const pairHtml = [];
    for (let i = 0; i < flat.length; i += 2) {
      const a = flat[i];
      const b = flat[i + 1];

      const aHtml = `<span style="color:${colors[a.ci % colors.length]}">${a.ch}</span>`;
      const bHtml = b ? `<span style="color:${colors[b.ci % colors.length]}">${b.ch}</span>` : "";
      pairHtml.push(aHtml + bHtml);
    }
    return pairHtml.join(" ");
  }

  // =========================
  // Sections show rules:
  // - checkbox checked => always show
  // - unchecked => show only while pressing button
  // =========================
  const holdState = { corners: false, edges: false };

  function computeShow(section){
    const cb = $(section + "-cb");
    return !!(cb && cb.checked) || !!holdState[section];
  }

  function updateSectionVisibility(){
    $("corners-letters").classList.toggle("show", computeShow("corners"));
    $("edges-letters").classList.toggle("show", computeShow("edges"));
  }

  function wireHoldButton(section){
    const btn = $(section + "-btn");

    const down = (e) => {
      e.preventDefault();
      holdState[section] = true;
      updateSectionVisibility();
    };
    const up = () => {
      holdState[section] = false;
      updateSectionVisibility();
    };

    btn.addEventListener("pointerdown", down);
    btn.addEventListener("pointerup", up);
    btn.addEventListener("pointercancel", up);
    btn.addEventListener("pointerleave", up);

    // Fallbacks
    btn.addEventListener("mousedown", down);
    btn.addEventListener("mouseup", up);
    btn.addEventListener("mouseleave", up);
    btn.addEventListener("touchstart", down, { passive:false });
    btn.addEventListener("touchend", up);
    btn.addEventListener("touchcancel", up);
  }

  // =========================
  // Set scramble => update twisty + compute tracks
  // =========================
  function setScramble(scramble) {
    const s = normalizeScrambleText(scramble);
    setEditorScramble(s);

    const twisty = $("twisty");
    twisty.setAttribute("experimental-setup-alg", s);
    twisty.alg = "";

    const cornerCycles = bufferMultiCyclesWithCornerCut(s);
    const edgeCycles   = bufferMultiCyclesEdgesWithCut(s);

    $("track").innerHTML = `
      <div class="section" id="corners-section">
        <div class="section-head">
          <button class="section-btn" id="corners-btn" type="button">CORNERS</button>
          <label class="section-check">
            <input type="checkbox" id="corners-cb" checked />
            Show
          </label>
        </div>
        <div class="track-letters show" id="corners-letters">${renderTrackHTML(cornerCycles)}</div>
      </div>

      <div class="spacer"></div>

      <div class="section" id="edges-section">
        <div class="section-head">
          <button class="section-btn" id="edges-btn" type="button">EDGES</button>
          <label class="section-check">
            <input type="checkbox" id="edges-cb" checked />
            Show
          </label>
        </div>
        <div class="track-letters show" id="edges-letters">${renderTrackHTML(edgeCycles)}</div>
      </div>
    `;

    $("corners-cb").addEventListener("change", updateSectionVisibility);
    $("edges-cb").addEventListener("change", updateSectionVisibility);

    wireHoldButton("corners");
    wireHoldButton("edges");

    updateSectionVisibility();
  }

  // Prevent spam-click issues during async scramble generation
  let generating = false;
  async function updateScrambleNew() {
    if (generating) return;
    generating = true;
    $("btn-new").disabled = true;

    try{
      const s = await generateScrambleWCA333();
      // cubing.js scrambles are WCA notation for 333 and use generator moves
      setScramble(s);
    } finally {
      generating = false;
      $("btn-new").disabled = false;
    }
  }

  // Tools
  $("btn-new").addEventListener("click", updateScrambleNew);

  $("btn-copy").addEventListener("click", async () => {
    const s = getScrambleFromEditor();
    try {
      await navigator.clipboard.writeText(s);
    } catch {
      const ta = document.createElement("textarea");
      ta.value = s;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
    }
  });

  $("btn-clear").addEventListener("click", () => {
    setEditorScramble("");
  });

  $("btn-apply").addEventListener("click", () => {
    const s = getScrambleFromEditor();
    if (!isValidGeneratorScramble(s)) {
      alert("Invalid scramble. Only generator moves are allowed: R L U D F B with optional ' or 2, separated by spaces.");
      return;
    }
    setScramble(s);
  });

  // Initial
  window.addEventListener("load", updateScrambleNew);

  // =========================
  // BLIND_SCHEME (ignore setup)
  // =========================
  const BLIND_SCHEME = {
    edges: {
      UF: { stickers: { U: { letter: "C" },   F: { letter: "I" } } },
      UR: { stickers: { U: { letter: "B" },   R: { letter: "M" } } },
      UB: { stickers: { U: { letter: "A" },   B: { letter: "Q" } } },
      UL: { stickers: { U: { letter: "D" },   L: { letter: "E" } } },
      DF: { stickers: { D: { letter: "U" },   F: { letter: "K" } } },
      DR: { stickers: { D: { letter: "V" },   R: { letter: "O" } } },
      DB: { stickers: { D: { letter: "W" },   B: { letter: "S" } } },
      DL: { stickers: { D: { letter: "X" },   L: { letter: "G" } } },
      FR: { stickers: { F: { letter: "J" },   R: { letter: "P" } } },
      BR: { stickers: { B: { letter: "T" },   R: { letter: "N" } } },
      BL: { stickers: { B: { letter: "R" },   L: { letter: "H" } } },
      FL: { stickers: { F: { letter: "L" },   L: { letter: "F" } } },
    },
    corners: {
      UFR: { stickers: { U: { letter: "C" },   F: { letter: "J" },   R: { letter: "M" } } },
      URB: { stickers: { U: { letter: "B" },   R: { letter: "N" },   B: { letter: "Q" } } },
      UBL: { stickers: { U: { letter: "A" },   B: { letter: "R" },   L: { letter: "E" } } },
      ULF: { stickers: { U: { letter: "D" },   L: { letter: "F" },   F: { letter: "I" } } },
      DFR: { stickers: { D: { letter: "V" },   F: { letter: "K" },   R: { letter: "P" } } },
      DRB: { stickers: { D: { letter: "W" },   R: { letter: "O" },   B: { letter: "T" } } },
      DBL: { stickers: { D: { letter: "X" },   B: { letter: "S" },   L: { letter: "H" } } },
      DLF: { stickers: { D: { letter: "U" },   L: { letter: "G" },   F: { letter: "L" } } },
    }
  };

  // =========================
  // Solved corner letters (54)
  // =========================
  function solvedCornerLetters54() {
    const a = Array(54).fill(".");
    a[0] = "A"; a[2] = "B"; a[8] = "C"; a[6] = "D";
    a[36] = "E"; a[38] = "F"; a[44] = "G"; a[42] = "H";
    a[18] = "I"; a[20] = "J"; a[26] = "K"; a[24] = "L";
    a[9]  = "M"; a[11] = "N"; a[17] = "O"; a[15] = "P";
    a[45] = "Q"; a[47] = "R"; a[53] = "S"; a[51] = "T";
    a[27] = "U"; a[29] = "V"; a[35] = "W"; a[33] = "X";
    return a;
  }

  // =========================
  // Solved edge letters (54)
  // NOTE: B-face left/right swapped to match your moveB orientation.
  // =========================
  function solvedEdgeLetters54() {
    const a = Array(54).fill(".");
    const U=0, R=9, F=18, D=27, L=36, B=45;

    a[U+7] = BLIND_SCHEME.edges.UF.stickers.U.letter; a[F+1] = BLIND_SCHEME.edges.UF.stickers.F.letter; // C I
    a[U+5] = BLIND_SCHEME.edges.UR.stickers.U.letter; a[R+1] = BLIND_SCHEME.edges.UR.stickers.R.letter; // B M
    a[U+1] = BLIND_SCHEME.edges.UB.stickers.U.letter; a[B+1] = BLIND_SCHEME.edges.UB.stickers.B.letter; // A Q
    a[U+3] = BLIND_SCHEME.edges.UL.stickers.U.letter; a[L+1] = BLIND_SCHEME.edges.UL.stickers.L.letter; // D E

    a[D+1] = BLIND_SCHEME.edges.DF.stickers.D.letter; a[F+7] = BLIND_SCHEME.edges.DF.stickers.F.letter; // U K
    a[D+5] = BLIND_SCHEME.edges.DR.stickers.D.letter; a[R+7] = BLIND_SCHEME.edges.DR.stickers.R.letter; // V O
    a[D+7] = BLIND_SCHEME.edges.DB.stickers.D.letter; a[B+7] = BLIND_SCHEME.edges.DB.stickers.B.letter; // W S
    a[D+3] = BLIND_SCHEME.edges.DL.stickers.D.letter; a[L+7] = BLIND_SCHEME.edges.DL.stickers.L.letter; // X G

    a[F+5] = BLIND_SCHEME.edges.FR.stickers.F.letter; a[R+3] = BLIND_SCHEME.edges.FR.stickers.R.letter; // J P
    a[B+3] = BLIND_SCHEME.edges.BR.stickers.B.letter; a[R+5] = BLIND_SCHEME.edges.BR.stickers.R.letter; // T N (swapped)
    a[B+5] = BLIND_SCHEME.edges.BL.stickers.B.letter; a[L+3] = BLIND_SCHEME.edges.BL.stickers.L.letter; // R H (swapped)
    a[F+3] = BLIND_SCHEME.edges.FL.stickers.F.letter; a[L+5] = BLIND_SCHEME.edges.FL.stickers.L.letter; // L F

    return a;
  }

  // =========================
  // Cube moves
  // =========================
  function rotateFaceCW(arr, base) {
    const i = base;
    const t0 = arr[i+0], t1 = arr[i+1], t2 = arr[i+2],
          t3 = arr[i+3],           t5 = arr[i+5],
          t6 = arr[i+6], t7 = arr[i+7], t8 = arr[i+8];

    arr[i+0] = t6; arr[i+1] = t3; arr[i+2] = t0;
    arr[i+3] = t7;              arr[i+5] = t1;
    arr[i+6] = t8; arr[i+7] = t5; arr[i+8] = t2;
  }

  function moveU(a){
    rotateFaceCW(a, 0);
    const F=18, R=9, B=45, L=36;
    const t = [a[F+0],a[F+1],a[F+2]];
    [a[F+0],a[F+1],a[F+2]] = [a[R+0],a[R+1],a[R+2]];
    [a[R+0],a[R+1],a[R+2]] = [a[B+0],a[B+1],a[B+2]];
    [a[B+0],a[B+1],a[B+2]] = [a[L+0],a[L+1],a[L+2]];
    [a[L+0],a[L+1],a[L+2]] = t;
  }

  function moveD(a){
    rotateFaceCW(a, 27);
    const F=18, R=9, B=45, L=36;
    const t = [a[F+6],a[F+7],a[F+8]];
    [a[F+6],a[F+7],a[F+8]] = [a[L+6],a[L+7],a[L+8]];
    [a[L+6],a[L+7],a[L+8]] = [a[B+6],a[B+7],a[B+8]];
    [a[B+6],a[B+7],a[B+8]] = [a[R+6],a[R+7],a[R+8]];
    [a[R+6],a[R+7],a[R+8]] = t;
  }

  function moveR(a){
    rotateFaceCW(a, 9);
    const U=0, F=18, D=27, B=45;
    const t = [a[U+2],a[U+5],a[U+8]];
    [a[U+2],a[U+5],a[U+8]] = [a[F+2],a[F+5],a[F+8]];
    [a[F+2],a[F+5],a[F+8]] = [a[D+2],a[D+5],a[D+8]];
    [a[D+2],a[D+5],a[D+8]] = [a[B+6],a[B+3],a[B+0]];
    [a[B+6],a[B+3],a[B+0]] = t;
  }

  function moveL(a){
    rotateFaceCW(a, 36);
    const U=0, F=18, D=27, B=45;
    const t = [a[U+0],a[U+3],a[U+6]];
    [a[U+0],a[U+3],a[U+6]] = [a[B+8],a[B+5],a[B+2]];
    [a[B+8],a[B+5],a[B+2]] = [a[D+0],a[D+3],a[D+6]];
    [a[D+0],a[D+3],a[D+6]] = [a[F+0],a[F+3],a[F+6]];
    [a[F+0],a[F+3],a[F+6]] = t;
  }

  function moveF(a){
    rotateFaceCW(a, 18);
    const U=0, R=9, D=27, L=36;
    const t = [a[U+6],a[U+7],a[U+8]];
    [a[U+6],a[U+7],a[U+8]] = [a[L+8],a[L+5],a[L+2]];
    [a[L+8],a[L+5],a[L+2]] = [a[D+2],a[D+1],a[D+0]];
    [a[D+2],a[D+1],a[D+0]] = [a[R+0],a[R+3],a[R+6]];
    [a[R+0],a[R+3],a[R+6]] = t;
  }

  function moveB(a){
    rotateFaceCW(a, 45);
    const U=0, R=9, D=27, L=36;
    const t = [a[U+0],a[U+1],a[U+2]];
    [a[U+0],a[U+1],a[U+2]] = [a[R+2],a[R+5],a[R+8]];
    [a[R+2],a[R+5],a[R+8]] = [a[D+8],a[D+7],a[D+6]];
    [a[D+8],a[D+7],a[D+6]] = [a[L+6],a[L+3],a[L+0]];
    [a[L+6],a[L+3],a[L+0]] = t;
  }

  function applyMove(a, face){
    switch(face){
      case "U": return moveU(a);
      case "D": return moveD(a);
      case "R": return moveR(a);
      case "L": return moveL(a);
      case "F": return moveF(a);
      case "B": return moveB(a);
    }
  }

  function applyAlg(a, algStr){
    const tokens = algStr.trim().split(/\s+/).filter(Boolean);
    for (const tok of tokens){
      const face = tok[0];
      const suffix = tok.slice(1);

      let times = 1;
      if (suffix === "2") times = 2;
      else if (suffix === "'") times = 3;

      for (let i=0; i<times; i++) applyMove(a, face);
    }
  }

  // =========================
  // CORNERS multi-cycle (with buffer piece pre-visited)
  // =========================
  function bufferMultiCyclesWithCornerCut(scramble){
    const solved = solvedCornerLetters54();
    const cur = solvedCornerLetters54();
    applyAlg(cur, scramble);

    const STOP = new Set(["A","R","E"]);
    const CORNERS = [
      ["A","E","R"], // UBL
      ["B","N","Q"], // URB
      ["C","J","M"], // UFR
      ["D","F","I"], // ULF
      ["U","L","G"], // DLF
      ["V","K","P"], // DFR
      ["W","O","T"], // DRB
      ["X","H","S"], // DBL
    ];
    const cornerOf = new Map();
    CORNERS.forEach((grp, i) => grp.forEach(ch => cornerOf.set(ch, i)));

    const idxOf = (letter) => solved.indexOf(letter);
    const cornerId = (letter) => cornerOf.get(letter);
    const posLetters = solved.filter(x => x !== ".");

    const visitedCornerGlobal = new Set();
    const processedStartCorners = new Set();

    const bufferCornerId = cornerId("E");
    if (bufferCornerId !== undefined) {
      visitedCornerGlobal.add(bufferCornerId);
      processedStartCorners.add(bufferCornerId);
    }

    function markGlobal(letter){
      if (STOP.has(letter)) return;
      const cid = cornerId(letter);
      if (cid !== undefined) visitedCornerGlobal.add(cid);
    }

    function runFromEUntilARE(){
      let p = "E";
      const out = [];
      const cycleVisited = new Set();

      for (let step = 0; step < 80; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (STOP.has(s)) break;

        const cidS = cornerId(s);
        if (cidS !== undefined && cycleVisited.has(cidS)) break;

        out.push(s);
        if (cidS !== undefined) cycleVisited.add(cidS);
        markGlobal(s);
        p = s;
      }
      return out;
    }

    function runCycleFrom(start){
      let p = start;
      const startCid = cornerId(start);

      const out = [start];
      const cycleVisited = new Set();

      for (let step = 0; step < 120; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (s === start && out.length === 1) return [];
        if (STOP.has(s)) break;

        const cidS = cornerId(s);
        if (cidS !== undefined && cycleVisited.has(cidS)) break;

        if (cidS !== undefined && cidS === startCid && out.length > 1) {
          out.push(s);
          markGlobal(s);
          break;
        }

        out.push(s);
        if (cidS !== undefined) cycleVisited.add(cidS);
        markGlobal(s);
        p = s;
      }
      return (out.length > 1) ? out : [];
    }

    const cycles = [];
    const first = runFromEUntilARE();
    if (first.length) cycles.push(first);

    while (true){
      let nextStart = null;

      for (const p of posLetters){
        if (STOP.has(p)) continue;
        const cid = cornerId(p);
        if (cid === undefined) continue;
        if (processedStartCorners.has(cid)) continue;
        if (visitedCornerGlobal.has(cid)) continue;
        nextStart = p; break;
      }

      if (!nextStart) break;

      const cid = cornerId(nextStart);
      if (cid !== undefined) processedStartCorners.add(cid);

      const c = runCycleFrom(nextStart);
      if (c.length) cycles.push(c);
      if (cycles.length > 30) break;
    }

    return cycles;
  }

  // =========================
  // EDGES multi-cycle
  // =========================
  function bufferMultiCyclesEdgesWithCut(scramble){
    const solved = solvedEdgeLetters54();
    const cur = solvedEdgeLetters54();
    applyAlg(cur, scramble);

    const EDGES = [
      ["C","I"], // UF
      ["B","M"], // UR
      ["A","Q"], // UB
      ["D","E"], // UL
      ["U","K"], // DF buffer piece
      ["V","O"], // DR
      ["W","S"], // DB
      ["X","G"], // DL
      ["J","P"], // FR
      ["T","N"], // BR
      ["R","H"], // BL
      ["L","F"], // FL
    ];

    const edgeOf = new Map();
    EDGES.forEach((grp, i) => grp.forEach(ch => edgeOf.set(ch, i)));

    const idxOf  = (letter) => solved.indexOf(letter);
    const edgeId = (letter) => edgeOf.get(letter);
    const posLetters = solved.filter(x => x !== ".");

    const BUFFER = BLIND_SCHEME.edges.DF.stickers.D.letter; // "U"
    const bufferEid = edgeId(BUFFER);

    const otherOnSameEdge = (letter) => {
      const eid = edgeId(letter);
      if (eid === undefined) return null;
      const pair = EDGES[eid];
      return (pair[0] === letter) ? pair[1] : pair[0];
    };
    const BUFFER_MATE = otherOnSameEdge(BUFFER); // "K"

    const STOP = new Set([BUFFER]);
    if (BUFFER_MATE) STOP.add(BUFFER_MATE);

    const lowPriorityLetters = ["Q","C","I","W","S"];
    const lowPriorityEdgeIds = new Set(
      lowPriorityLetters.map(ch => edgeId(ch)).filter(eid => eid !== undefined)
    );

    const visitedEdgeGlobal = new Set();
    const processedStartEdges = new Set();

    if (bufferEid !== undefined) {
      visitedEdgeGlobal.add(bufferEid);
      processedStartEdges.add(bufferEid);
    }

    function markGlobal(letter){
      if (STOP.has(letter)) return;
      const eid = edgeId(letter);
      if (eid !== undefined) visitedEdgeGlobal.add(eid);
    }

    function runFromBufferUntilStop(){
      let p = BUFFER;
      const out = [];
      const cycleVisited = new Set();

      for (let step = 0; step < 80; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (STOP.has(s)) break;

        const eidS = edgeId(s);
        if (eidS !== undefined && cycleVisited.has(eidS)) break;

        out.push(s);
        if (eidS !== undefined) cycleVisited.add(eidS);
        markGlobal(s);
        p = s;
      }
      return out;
    }

    function runCycleFrom(start){
      let p = start;
      const startEid = edgeId(start);

      const out = [start];
      const cycleVisited = new Set();

      for (let step = 0; step < 120; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (s === start && out.length === 1) return [];
        if (STOP.has(s)) break;

        const eidS = edgeId(s);
        if (eidS !== undefined && cycleVisited.has(eidS)) break;

        if (eidS !== undefined && eidS === startEid && out.length > 1) {
          out.push(s);
          markGlobal(s);
          break;
        }

        out.push(s);
        if (eidS !== undefined) cycleVisited.add(eidS);
        markGlobal(s);
        p = s;
      }
      return (out.length > 1) ? out : [];
    }

    function isEligibleStart(p){
      if (STOP.has(p)) return false;
      const eid = edgeId(p);
      if (eid === undefined) return false;
      if (processedStartEdges.has(eid)) return false;
      if (visitedEdgeGlobal.has(eid)) return false;
      return true;
    }

    function pickNextStart(){
      if (isEligibleStart("A")) return "A";

      for (const p of posLetters){
        if (!isEligibleStart(p)) continue;
        const eid = edgeId(p);
        if (lowPriorityEdgeIds.has(eid)) continue;
        return p;
      }

      for (const p of posLetters){
        if (!isEligibleStart(p)) continue;
        return p;
      }

      return null;
    }

    const cycles = [];
    const first = runFromBufferUntilStop();
    if (first.length) cycles.push(first);

    while (true){
      const nextStart = pickNextStart();
      if (!nextStart) break;

      const eid = edgeId(nextStart);
      if (eid !== undefined) processedStartEdges.add(eid);

      const c = runCycleFrom(nextStart);
      if (c.length) cycles.push(c);

      if (cycles.length > 30) break;
    }

    return cycles;
  }
</script>

</body>
</html>
