<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SCRAMBLE</title>

  <style>
    body{
      background:black;
      color:white;
      font-family:sans-serif;
      margin:0;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    h1{ position:absolute; top:20px; margin:0; }
    a.back{
      position:absolute;
      top:20px; left:20px;
      color:white; text-decoration:none; font-size:16px;
    }

    #scramble-row{
      display:flex;
      align-items:center;
      gap:12px;
      margin-bottom:18px;
      max-width:92vw;
      width:92vw;
      justify-content:center;
      flex-wrap:wrap;
    }

    #scramble-editor{
      font-size:22px;
      color:#aaa;
      max-width:70vw;
      width:min(760px, 70vw);
      text-align:center;
      word-break:break-word;
      line-height:1.4;
      outline:none;

      padding:10px 12px;
      border:1px solid #222;
      border-radius:10px;
      background:#0b0b0b;
      cursor:text;
      user-select:text;
    }
    #scramble-editor:focus{
      border-color:#444;
      box-shadow:0 0 0 2px rgba(255,255,255,0.06);
    }

    #scramble-tools{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .tool-btn{
      padding:10px 14px;
      font-size:16px;
      background:#222;
      color:white;
      border:none;
      border-radius:8px;
      cursor:pointer;
      white-space:nowrap;
    }
    .tool-btn:hover{ background:#333; }
    .tool-btn:disabled{
      opacity:0.55;
      cursor:not-allowed;
    }

    #scramble-hint{
      margin-top:6px;
      font-size:12px;
      color:#666;
      text-align:center;
      max-width:92vw;
    }

    twisty-player{ width:280px; height:280px; }

    #track{
      margin-top:16px;
      color:#fff;
      font-weight:700;
      letter-spacing:2px;
      text-align:center;
      max-width:92vw;
      word-break:break-word;
      line-height:1.2;
    }

    .section{ margin-top:10px; }
    .section-head{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .section-btn{
      font-size:32px;
      padding:8px 14px;
      background:#111;
      color:#fff;
      border:1px solid #333;
      border-radius:12px;
      cursor:pointer;
      user-select:none;
      touch-action:manipulation;
    }
    .section-btn:hover{ background:#171717; }

    .section-check{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:16px;
      color:#ddd;
      user-select:none;
    }
    .section-check input{
      width:18px;
      height:18px;
      cursor:pointer;
    }

    /* keep layout stable */
    .track-letters{
      font-size:44px;
      line-height:1.2;
      max-width:92vw;
      margin:0 auto;

      display:block;
      visibility:hidden;
      opacity:0;
      pointer-events:none;
      transition: opacity 80ms linear;
    }
    .track-letters.show{
      visibility:visible;
      opacity:1;
    }

    .spacer{ height:18px; }
  </style>

  <script type="module">
    import "https://cdn.cubing.net/v0/js/cubing/twisty";
    import { randomScrambleForEvent } from "https://cdn.cubing.net/v0/js/cubing/scramble";
    window.randomScrambleForEvent = randomScrambleForEvent;
  </script>
</head>

<body>
  <h1>SCRAMBLE</h1>
  <a href="index.html" class="back">‚Üê Back to Home</a>

  <div id="scramble-row">
    <div id="scramble-editor" contenteditable="true" spellcheck="false"></div>
    <div id="scramble-tools">
      <button class="tool-btn" id="btn-new">New</button>
      <button class="tool-btn" id="btn-copy">Copy</button>
      <button class="tool-btn" id="btn-clear">Clear</button>
      <button class="tool-btn" id="btn-apply">Apply</button>
    </div>
  </div>
  <div id="scramble-hint">
    Apply supports: R L U D F B + M E S + wide r u f d b + rotations x y z, with optional ' or 2.
    If center-moves are used, Apply will append x/y/z at the end to restore White-Up Green-Front.
  </div>

  <twisty-player
    id="twisty"
    puzzle="3x3x3"
    hint-facelets="floating"
    background="none"
    control-panel="none"
  ></twisty-player>

  <div id="track"></div>

<script>
  const $ = (id) => document.getElementById(id);

  // =========================
  // Scramble helpers
  // =========================
  function normalizeScrambleText(s){
    return (s || "").trim().replace(/\s+/g, " ");
  }

  // Supported tokens:
  // R L U D F B, M E S, wide r u f d b, rotations x y z (+ ' / 2)
  function isValidSupportedScramble(s){
    const t = normalizeScrambleText(s);
    if (!t) return false;
    const tokens = t.split(" ");
    const re = /^[RLUDFBMESrufdbxyz](2|')?$/;
    return tokens.every(tok => re.test(tok));
  }

  function getScrambleFromEditor(){
    return normalizeScrambleText($("scramble-editor").textContent);
  }

  function setEditorScramble(s){
    $("scramble-editor").textContent = s;
  }

  // =========================
  // WCA-style random-state scramble (cubing.js)
  // =========================
  async function generateScrambleWCA333() {
    const alg = await window.randomScrambleForEvent("333");
    return alg.toString();
  }

  // =========================
  // Sections show rules
  // =========================
  const holdState = { corners: false, edges: false };
  const uiState = {
    showCorners: true,
    showEdges: true,
  };

  function computeShow(section){
    const cb = $(section + "-cb");
    return !!(cb && cb.checked) || !!holdState[section];
  }

  function updateSectionVisibility(){
    $("corners-letters").classList.toggle("show", computeShow("corners"));
    $("edges-letters").classList.toggle("show", computeShow("edges"));
  }

  function wireHoldButton(section){
    const btn = $(section + "-btn");

    const down = (e) => {
      e.preventDefault();
      holdState[section] = true;
      updateSectionVisibility();
    };
    const up = () => {
      holdState[section] = false;
      updateSectionVisibility();
    };

    btn.addEventListener("pointerdown", down);
    btn.addEventListener("pointerup", up);
    btn.addEventListener("pointercancel", up);
    btn.addEventListener("pointerleave", up);

    btn.addEventListener("mousedown", down);
    btn.addEventListener("mouseup", up);
    btn.addEventListener("mouseleave", up);
    btn.addEventListener("touchstart", down, { passive:false });
    btn.addEventListener("touchend", up);
    btn.addEventListener("touchcancel", up);
  }

  // =========================
  // Track renderer
  // =========================
  function renderTrackHTML(cycles) {
    const colors = [
      "#ffd166", "#06d6a0", "#4cc9f0", "#f72585",
      "#b8f2e6", "#fca311", "#a78bfa", "#80ed99",
    ];

    const flat = [];
    cycles.forEach((letters, ci) => {
      letters.forEach(ch => flat.push({ ch, ci }));
    });

    const pairHtml = [];
    for (let i = 0; i < flat.length; i += 2) {
      const a = flat[i];
      const b = flat[i + 1];

      const aHtml = `<span style="color:${colors[a.ci % colors.length]}">${a.ch}</span>`;
      const bHtml = b ? `<span style="color:${colors[b.ci % colors.length]}">${b.ch}</span>` : "";
      pairHtml.push(aHtml + bHtml);
    }
    return pairHtml.join(" ");
  }

  // =========================
  // Set scramble => update twisty + compute tracks
  // =========================
  function setScramble(scramble) {
    const s = normalizeScrambleText(scramble);
    setEditorScramble(s);

    const twisty = $("twisty");
    twisty.setAttribute("experimental-setup-alg", s);
    twisty.alg = "";

    const cornerCycles = bufferMultiCyclesWithCornerCut(s);
    const edgeCycles   = bufferMultiCyclesEdgesWithCut(s);

$("track").innerHTML = `
  <div class="section" id="corners-section">
    <div class="section-head">
      <button class="section-btn" id="corners-btn" type="button">CORNERS</button>
      <label class="section-check">
        <input type="checkbox" id="corners-cb" ${uiState.showCorners ? "checked" : ""} />
        Show
      </label>
    </div>
    <div class="track-letters ${uiState.showCorners ? "show" : ""}" id="corners-letters">
      ${renderTrackHTML(cornerCycles)}
    </div>
  </div>

  <div class="spacer"></div>

  <div class="section" id="edges-section">
    <div class="section-head">
      <button class="section-btn" id="edges-btn" type="button">EDGES</button>
      <label class="section-check">
        <input type="checkbox" id="edges-cb" ${uiState.showEdges ? "checked" : ""} />
        Show
      </label>
    </div>
    <div class="track-letters ${uiState.showEdges ? "show" : ""}" id="edges-letters">
      ${renderTrackHTML(edgeCycles)}
    </div>
  </div>
`;


    $("corners-cb").addEventListener("change", (e) => {
      uiState.showCorners = e.target.checked;
      updateSectionVisibility();
    });
    $("edges-cb").addEventListener("change", (e) => {
      uiState.showEdges = e.target.checked;
      updateSectionVisibility();
    });

    wireHoldButton("corners");
    wireHoldButton("edges");

    updateSectionVisibility();
  }

  // async New
  let generating = false;
  async function updateScrambleNew() {
    if (generating) return;
    generating = true;
    $("btn-new").disabled = true;

    try{
      const s = await generateScrambleWCA333();
      setScramble(s);
    } finally {
      generating = false;
      $("btn-new").disabled = false;
    }
  }

  // Tools
  $("btn-new").addEventListener("click", updateScrambleNew);

  $("btn-copy").addEventListener("click", async () => {
    const s = getScrambleFromEditor();
    try {
      await navigator.clipboard.writeText(s);
    } catch {
      const ta = document.createElement("textarea");
      ta.value = s;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
    }
  });

  $("btn-clear").addEventListener("click", () => {
    setEditorScramble("");
  });

  $("btn-apply").addEventListener("click", () => {
    const raw = getScrambleFromEditor();
    if (!isValidSupportedScramble(raw)) {
      alert("Invalid scramble.\nSupported: R L U D F B + M E S + wide r u f d b + rotations x y z, with optional ' or 2.");
      return;
    }

    const fixed = appendXYZToRestoreWhiteUpGreenFront(raw);
    setScramble(fixed);
  });

  window.addEventListener("load", updateScrambleNew);

  // ============================================================
  // BLIND_SCHEME
  // ============================================================
  const BLIND_SCHEME = {
    edges: {
      UF: { stickers: { U: { letter: "C" },   F: { letter: "I" } } },
      UR: { stickers: { U: { letter: "B" },   R: { letter: "M" } } },
      UB: { stickers: { U: { letter: "A" },   B: { letter: "Q" } } },
      UL: { stickers: { U: { letter: "D" },   L: { letter: "E" } } },
      DF: { stickers: { D: { letter: "U" },   F: { letter: "K" } } },
      DR: { stickers: { D: { letter: "V" },   R: { letter: "O" } } },
      DB: { stickers: { D: { letter: "W" },   B: { letter: "S" } } },
      DL: { stickers: { D: { letter: "X" },   L: { letter: "G" } } },
      FR: { stickers: { F: { letter: "J" },   R: { letter: "P" } } },
      BR: { stickers: { B: { letter: "T" },   R: { letter: "N" } } },
      BL: { stickers: { B: { letter: "R" },   L: { letter: "H" } } },
      FL: { stickers: { F: { letter: "L" },   L: { letter: "F" } } },
    },
    corners: {
      UFR: { stickers: { U: { letter: "C" },   F: { letter: "J" },   R: { letter: "M" } } },
      URB: { stickers: { U: { letter: "B" },   R: { letter: "N" },   B: { letter: "Q" } } },
      UBL: { stickers: { U: { letter: "A" },   B: { letter: "R" },   L: { letter: "E" } } },
      ULF: { stickers: { U: { letter: "D" },   L: { letter: "F" },   F: { letter: "I" } } },
      DFR: { stickers: { D: { letter: "V" },   F: { letter: "K" },   R: { letter: "P" } } },
      DRB: { stickers: { D: { letter: "W" },   R: { letter: "O" },   B: { letter: "T" } } },
      DBL: { stickers: { D: { letter: "X" },   B: { letter: "S" },   L: { letter: "H" } } },
      DLF: { stickers: { D: { letter: "U" },   L: { letter: "G" },   F: { letter: "L" } } },
    }
  };

  // ============================================================
  // Solved letters (54)
  // ============================================================
  function solvedCornerLetters54() {
    const a = Array(54).fill(".");
    a[0] = "A"; a[2] = "B"; a[8] = "C"; a[6] = "D";
    a[36] = "E"; a[38] = "F"; a[44] = "G"; a[42] = "H";
    a[18] = "I"; a[20] = "J"; a[26] = "K"; a[24] = "L";
    a[9]  = "M"; a[11] = "N"; a[17] = "O"; a[15] = "P";
    a[45] = "Q"; a[47] = "R"; a[53] = "S"; a[51] = "T";
    a[27] = "U"; a[29] = "V"; a[35] = "W"; a[33] = "X";
    return a;
  }

  function solvedEdgeLetters54() {
    const a = Array(54).fill(".");
    const U=0, R=9, F=18, D=27, L=36, B=45;

    a[U+7] = BLIND_SCHEME.edges.UF.stickers.U.letter; a[F+1] = BLIND_SCHEME.edges.UF.stickers.F.letter;
    a[U+5] = BLIND_SCHEME.edges.UR.stickers.U.letter; a[R+1] = BLIND_SCHEME.edges.UR.stickers.R.letter;
    a[U+1] = BLIND_SCHEME.edges.UB.stickers.U.letter; a[B+1] = BLIND_SCHEME.edges.UB.stickers.B.letter;
    a[U+3] = BLIND_SCHEME.edges.UL.stickers.U.letter; a[L+1] = BLIND_SCHEME.edges.UL.stickers.L.letter;

    a[D+1] = BLIND_SCHEME.edges.DF.stickers.D.letter; a[F+7] = BLIND_SCHEME.edges.DF.stickers.F.letter;
    a[D+5] = BLIND_SCHEME.edges.DR.stickers.D.letter; a[R+7] = BLIND_SCHEME.edges.DR.stickers.R.letter;
    a[D+7] = BLIND_SCHEME.edges.DB.stickers.D.letter; a[B+7] = BLIND_SCHEME.edges.DB.stickers.B.letter;
    a[D+3] = BLIND_SCHEME.edges.DL.stickers.D.letter; a[L+7] = BLIND_SCHEME.edges.DL.stickers.L.letter;

    a[F+5] = BLIND_SCHEME.edges.FR.stickers.F.letter; a[R+3] = BLIND_SCHEME.edges.FR.stickers.R.letter;
    a[B+3] = BLIND_SCHEME.edges.BR.stickers.B.letter; a[R+5] = BLIND_SCHEME.edges.BR.stickers.R.letter;
    a[B+5] = BLIND_SCHEME.edges.BL.stickers.B.letter; a[L+3] = BLIND_SCHEME.edges.BL.stickers.L.letter;
    a[F+3] = BLIND_SCHEME.edges.FL.stickers.F.letter; a[L+5] = BLIND_SCHEME.edges.FL.stickers.L.letter;

    return a;
  }

  // ============================================================
  // Cube moves (faces)
  // ============================================================
  function rotateFaceCW(arr, base) {
    const i = base;
    const t0 = arr[i+0], t1 = arr[i+1], t2 = arr[i+2],
          t3 = arr[i+3],           t5 = arr[i+5],
          t6 = arr[i+6], t7 = arr[i+7], t8 = arr[i+8];

    arr[i+0] = t6; arr[i+1] = t3; arr[i+2] = t0;
    arr[i+3] = t7;              arr[i+5] = t1;
    arr[i+6] = t8; arr[i+7] = t5; arr[i+8] = t2;
  }

  function moveU(a){
    rotateFaceCW(a, 0);
    const F=18, R=9, B=45, L=36;
    const t = [a[F+0],a[F+1],a[F+2]];
    [a[F+0],a[F+1],a[F+2]] = [a[R+0],a[R+1],a[R+2]];
    [a[R+0],a[R+1],a[R+2]] = [a[B+0],a[B+1],a[B+2]];
    [a[B+0],a[B+1],a[B+2]] = [a[L+0],a[L+1],a[L+2]];
    [a[L+0],a[L+1],a[L+2]] = t;
  }

  function moveD(a){
    rotateFaceCW(a, 27);
    const F=18, R=9, B=45, L=36;
    const t = [a[F+6],a[F+7],a[F+8]];
    [a[F+6],a[F+7],a[F+8]] = [a[L+6],a[L+7],a[L+8]];
    [a[L+6],a[L+7],a[L+8]] = [a[B+6],a[B+7],a[B+8]];
    [a[B+6],a[B+7],a[B+8]] = [a[R+6],a[R+7],a[R+8]];
    [a[R+6],a[R+7],a[R+8]] = t;
  }

  function moveR(a){
    rotateFaceCW(a, 9);
    const U=0, F=18, D=27, B=45;
    const t = [a[U+2],a[U+5],a[U+8]];
    [a[U+2],a[U+5],a[U+8]] = [a[F+2],a[F+5],a[F+8]];
    [a[F+2],a[F+5],a[F+8]] = [a[D+2],a[D+5],a[D+8]];
    [a[D+2],a[D+5],a[D+8]] = [a[B+6],a[B+3],a[B+0]];
    [a[B+6],a[B+3],a[B+0]] = t;
  }

  function moveL(a){
    rotateFaceCW(a, 36);
    const U=0, F=18, D=27, B=45;
    const t = [a[U+0],a[U+3],a[U+6]];
    [a[U+0],a[U+3],a[U+6]] = [a[B+8],a[B+5],a[B+2]];
    [a[B+8],a[B+5],a[B+2]] = [a[D+0],a[D+3],a[D+6]];
    [a[D+0],a[D+3],a[D+6]] = [a[F+0],a[F+3],a[F+6]];
    [a[F+0],a[F+3],a[F+6]] = t;
  }

  function moveF(a){
    rotateFaceCW(a, 18);
    const U=0, R=9, D=27, L=36;
    const t = [a[U+6],a[U+7],a[U+8]];
    [a[U+6],a[U+7],a[U+8]] = [a[L+8],a[L+5],a[L+2]];
    [a[L+8],a[L+5],a[L+2]] = [a[D+2],a[D+1],a[D+0]];
    [a[D+2],a[D+1],a[D+0]] = [a[R+0],a[R+3],a[R+6]];
    [a[R+0],a[R+3],a[R+6]] = t;
  }

  function moveB(a){
    rotateFaceCW(a, 45);
    const U=0, R=9, D=27, L=36;
    const t = [a[U+0],a[U+1],a[U+2]];
    [a[U+0],a[U+1],a[U+2]] = [a[R+2],a[R+5],a[R+8]];
    [a[R+2],a[R+5],a[R+8]] = [a[D+8],a[D+7],a[D+6]];
    [a[D+8],a[D+7],a[D+6]] = [a[L+6],a[L+3],a[L+0]];
    [a[L+6],a[L+3],a[L+0]] = t;
  }

  // ============================================================
  // Slice moves (M E S)
  // Convention:
  // M direction as L
  // E direction as D
  // S direction as F
  // ============================================================
  function moveM(a){
    const U=0, F=18, D=27, B=45;
    const t = [a[U+1],a[U+4],a[U+7]];
    [a[U+1],a[U+4],a[U+7]] = [a[B+7],a[B+4],a[B+1]];
    [a[B+7],a[B+4],a[B+1]] = [a[D+1],a[D+4],a[D+7]];
    [a[D+1],a[D+4],a[D+7]] = [a[F+1],a[F+4],a[F+7]];
    [a[F+1],a[F+4],a[F+7]] = t;
  }

  function moveE(a){
    const F=18, R=9, B=45, L=36;
    const t = [a[F+3],a[F+4],a[F+5]];
    [a[F+3],a[F+4],a[F+5]] = [a[L+3],a[L+4],a[L+5]];
    [a[L+3],a[L+4],a[L+5]] = [a[B+3],a[B+4],a[B+5]];
    [a[B+3],a[B+4],a[B+5]] = [a[R+3],a[R+4],a[R+5]];
    [a[R+3],a[R+4],a[R+5]] = t;
  }

  function moveS(a){
    const U=0, R=9, D=27, L=36;
    const t = [a[U+3],a[U+4],a[U+5]];
    [a[U+3],a[U+4],a[U+5]] = [a[L+7],a[L+4],a[L+1]];
    [a[L+7],a[L+4],a[L+1]] = [a[D+5],a[D+4],a[D+3]];
    [a[D+5],a[D+4],a[D+3]] = [a[R+1],a[R+4],a[R+7]];
    [a[R+1],a[R+4],a[R+7]] = t;
  }

  // ============================================================
  // Apply token (supports faces, slices, wide, and rotations)
  // Wide moves:
  // r = R + M'
  // u = U + E'
  // f = F + S
  // d = D + E
  // b = B + S'
  //
  // Rotations (implemented via face+slices):
  // x = R + M' + L'
  // y = U + E' + D'
  // z = F + S  + B'
  // ============================================================
  function applyBasic(a, mv){
    switch(mv){
      case "U": return moveU(a);
      case "D": return moveD(a);
      case "R": return moveR(a);
      case "L": return moveL(a);
      case "F": return moveF(a);
      case "B": return moveB(a);
      case "M": return moveM(a);
      case "E": return moveE(a);
      case "S": return moveS(a);
    }
  }

  function times(fn, a, n){ for (let i=0;i<n;i++) fn(a); }
  function prime(fn, a){ times(fn, a, 3); } // inverse

  function wideQuarter(a, w){
    switch(w){
      case "r": moveR(a); prime(moveM, a); return;
      case "u": moveU(a); prime(moveE, a); return;
      case "f": moveF(a); moveS(a); return;
      case "d": moveD(a); moveE(a); return;
      case "b": moveB(a); prime(moveS, a); return;
    }
  }

  function rotQuarter(a, r){
    switch(r){
      case "x":
        moveR(a); prime(moveM, a); prime(moveL, a);
        return;
      case "y":
        moveU(a); prime(moveE, a); prime(moveD, a);
        return;
      case "z":
        moveF(a); moveS(a); prime(moveB, a);
        return;
    }
  }

  function applyMoveToken(a, move){
    if ("rufdb".includes(move)) return wideQuarter(a, move);
    if ("xyz".includes(move)) return rotQuarter(a, move);
    return applyBasic(a, move);
  }

  function applyAlg(a, algStr){
    const tokens = normalizeScrambleText(algStr).split(" ").filter(Boolean);
    for (const tok of tokens){
      const move = tok[0];
      const suffix = tok.slice(1);

      let t = 1;
      if (suffix === "2") t = 2;
      else if (suffix === "'") t = 3;

      for (let i=0;i<t;i++) applyMoveToken(a, move);
    }
  }

  // ============================================================
  // Auto-append x/y/z to restore White-Up Green-Front
  // Implementation: track centers by labeling them and BFS rotations.
  // Desired: U-center == "U" and F-center == "F"
  // ============================================================
  function initCenterState54(){
    const a = Array(54).fill(".");
    const U=0, R=9, F=18, D=27, L=36, B=45;
    a[U+4] = "U";
    a[R+4] = "R";
    a[F+4] = "F";
    a[D+4] = "D";
    a[L+4] = "L";
    a[B+4] = "B";
    return a;
  }

  function centersSignature(a){
    const U=0, R=9, F=18, D=27, L=36, B=45;
    return `${a[U+4]}${a[R+4]}${a[F+4]}${a[D+4]}${a[L+4]}${a[B+4]}`;
  }

  function isSolvedOrientationCenters(a){
    const U=0, F=18;
    return a[U+4] === "U" && a[F+4] === "F";
  }

  function findRotationSuffixToRestoreCenters(algStr){
    // If no center-affecting moves, skip.
    // Face turns don't move centers; slices/wide/rotations can.
    const tokens = normalizeScrambleText(algStr).split(" ").filter(Boolean);
    const affectsCenters = tokens.some(t => {
      const m = t[0];
      return "MESrufdbxyz".includes(m);
    });
    if (!affectsCenters) return "";

    const start = initCenterState54();
    applyAlg(start, algStr);

    if (isSolvedOrientationCenters(start)) return "";

    // BFS over rotations x y z (quarter turns only); depth<=6 is plenty for 24 orientations.
    const moves = ["x", "y", "z"];
    const seen = new Set();
    const q = [];

    const sig0 = centersSignature(start);
    seen.add(sig0);
    q.push({ state: start, path: [] });

    while (q.length){
      const cur = q.shift();
      if (cur.path.length > 6) continue;

      for (const mv of moves){
        const next = cur.state.slice();
        rotQuarter(next, mv);

        const sig = centersSignature(next);
        if (seen.has(sig)) continue;
        const path = cur.path.concat(mv);

        if (isSolvedOrientationCenters(next)){
          return path.join(" ");
        }

        seen.add(sig);
        q.push({ state: next, path });
      }
    }

    // Fallback (shouldn't happen): do nothing
    return "";
  }

  function appendXYZToRestoreWhiteUpGreenFront(algStr){
    const s = normalizeScrambleText(algStr);
    const suffix = findRotationSuffixToRestoreCenters(s);
    if (!suffix) return s;
    return `${s} ${suffix}`.trim();
  }

  // ============================================================
  // CORNERS multi-cycle (with buffer piece pre-visited)
  // ============================================================
  function bufferMultiCyclesWithCornerCut(scramble){
    const solved = solvedCornerLetters54();
    const cur = solvedCornerLetters54();
    applyAlg(cur, scramble);

    const STOP = new Set(["A","R","E"]);
    const CORNERS = [
      ["A","E","R"], ["B","N","Q"], ["C","J","M"], ["D","F","I"],
      ["U","L","G"], ["V","K","P"], ["W","O","T"], ["X","H","S"],
    ];
    const cornerOf = new Map();
    CORNERS.forEach((grp, i) => grp.forEach(ch => cornerOf.set(ch, i)));

    const idxOf = (letter) => solved.indexOf(letter);
    const cornerId = (letter) => cornerOf.get(letter);
    const posLetters = solved.filter(x => x !== ".");

    const visitedCornerGlobal = new Set();
    const processedStartCorners = new Set();

    const bufferCornerId = cornerId("E");
    if (bufferCornerId !== undefined) {
      visitedCornerGlobal.add(bufferCornerId);
      processedStartCorners.add(bufferCornerId);
    }

    function markGlobal(letter){
      if (STOP.has(letter)) return;
      const cid = cornerId(letter);
      if (cid !== undefined) visitedCornerGlobal.add(cid);
    }

    function runFromEUntilARE(){
      let p = "E";
      const out = [];
      const cycleVisited = new Set();

      for (let step = 0; step < 80; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (STOP.has(s)) break;

        const cidS = cornerId(s);
        if (cidS !== undefined && cycleVisited.has(cidS)) break;

        out.push(s);
        if (cidS !== undefined) cycleVisited.add(cidS);
        markGlobal(s);
        p = s;
      }
      return out;
    }

    function runCycleFrom(start){
      let p = start;
      const startCid = cornerId(start);

      const out = [start];
      const cycleVisited = new Set();

      for (let step = 0; step < 120; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (s === start && out.length === 1) return [];
        if (STOP.has(s)) break;

        const cidS = cornerId(s);
        if (cidS !== undefined && cycleVisited.has(cidS)) break;

        if (cidS !== undefined && cidS === startCid && out.length > 1) {
          out.push(s);
          markGlobal(s);
          break;
        }

        out.push(s);
        if (cidS !== undefined) cycleVisited.add(cidS);
        markGlobal(s);
        p = s;
      }
      return (out.length > 1) ? out : [];
    }

    const cycles = [];
    const first = runFromEUntilARE();
    if (first.length) cycles.push(first);

    while (true){
      let nextStart = null;

      for (const p of posLetters){
        if (STOP.has(p)) continue;
        const cid = cornerId(p);
        if (cid === undefined) continue;
        if (processedStartCorners.has(cid)) continue;
        if (visitedCornerGlobal.has(cid)) continue;
        nextStart = p; break;
      }

      if (!nextStart) break;

      const cid = cornerId(nextStart);
      if (cid !== undefined) processedStartCorners.add(cid);

      const c = runCycleFrom(nextStart);
      if (c.length) cycles.push(c);
      if (cycles.length > 30) break;
    }

    return cycles;
  }

  // ============================================================
  // EDGES multi-cycle
  // ============================================================
  function bufferMultiCyclesEdgesWithCut(scramble){
    const solved = solvedEdgeLetters54();
    const cur = solvedEdgeLetters54();
    applyAlg(cur, scramble);

    const EDGES = [
      ["C","I"], ["B","M"], ["A","Q"], ["D","E"],
      ["U","K"], ["V","O"], ["W","S"], ["X","G"],
      ["J","P"], ["T","N"], ["R","H"], ["L","F"],
    ];

    const edgeOf = new Map();
    EDGES.forEach((grp, i) => grp.forEach(ch => edgeOf.set(ch, i)));

    const idxOf  = (letter) => solved.indexOf(letter);
    const edgeId = (letter) => edgeOf.get(letter);
    const posLetters = solved.filter(x => x !== ".");

    const BUFFER = BLIND_SCHEME.edges.DF.stickers.D.letter; // "U"
    const bufferEid = edgeId(BUFFER);

    const otherOnSameEdge = (letter) => {
      const eid = edgeId(letter);
      if (eid === undefined) return null;
      const pair = EDGES[eid];
      return (pair[0] === letter) ? pair[1] : pair[0];
    };
    const BUFFER_MATE = otherOnSameEdge(BUFFER); // "K"

    const STOP = new Set([BUFFER]);
    if (BUFFER_MATE) STOP.add(BUFFER_MATE);

    const lowPriorityLetters = ["Q","C","I","W","S"];
    const lowPriorityEdgeIds = new Set(
      lowPriorityLetters.map(ch => edgeId(ch)).filter(eid => eid !== undefined)
    );

    const visitedEdgeGlobal = new Set();
    const processedStartEdges = new Set();

    if (bufferEid !== undefined) {
      visitedEdgeGlobal.add(bufferEid);
      processedStartEdges.add(bufferEid);
    }

    function markGlobal(letter){
      if (STOP.has(letter)) return;
      const eid = edgeId(letter);
      if (eid !== undefined) visitedEdgeGlobal.add(eid);
    }

    function runFromBufferUntilStop(){
      let p = BUFFER;
      const out = [];
      const cycleVisited = new Set();

      for (let step = 0; step < 80; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (STOP.has(s)) break;

        const eidS = edgeId(s);
        if (eidS !== undefined && cycleVisited.has(eidS)) break;

        out.push(s);
        if (eidS !== undefined) cycleVisited.add(eidS);
        markGlobal(s);
        p = s;
      }
      return out;
    }

    function runCycleFrom(start){
      let p = start;
      const startEid = edgeId(start);

      const out = [start];
      const cycleVisited = new Set();

      for (let step = 0; step < 120; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (s === start && out.length === 1) return [];
        if (STOP.has(s)) break;

        const eidS = edgeId(s);
        if (eidS !== undefined && cycleVisited.has(eidS)) break;

        if (eidS !== undefined && eidS === startEid && out.length > 1) {
          out.push(s);
          markGlobal(s);
          break;
        }

        out.push(s);
        if (eidS !== undefined) cycleVisited.add(eidS);
        markGlobal(s);
        p = s;
      }
      return (out.length > 1) ? out : [];
    }

    function isEligibleStart(p){
      if (STOP.has(p)) return false;
      const eid = edgeId(p);
      if (eid === undefined) return false;
      if (processedStartEdges.has(eid)) return false;
      if (visitedEdgeGlobal.has(eid)) return false;
      return true;
    }

    function pickNextStart(){
      if (isEligibleStart("A")) return "A";

      for (const p of posLetters){
        if (!isEligibleStart(p)) continue;
        const eid = edgeId(p);
        if (lowPriorityEdgeIds.has(eid)) continue;
        return p;
      }

      for (const p of posLetters){
        if (!isEligibleStart(p)) continue;
        return p;
      }
      return null;
    }

    const cycles = [];
    const first = runFromBufferUntilStop();
    if (first.length) cycles.push(first);

    while (true){
      const nextStart = pickNextStart();
      if (!nextStart) break;

      const eid = edgeId(nextStart);
      if (eid !== undefined) processedStartEdges.add(eid);

      const c = runCycleFrom(nextStart);
      if (c.length) cycles.push(c);

      if (cycles.length > 30) break;
    }

    return cycles;
  }
</script>

</body>
</html>
