<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SCRAMBLE</title>

  <style>
    body{
      background:black;
      color:white;
      font-family:sans-serif;
      margin:0;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
    }
    h1{ position:absolute; top:20px; margin:0; }
    a.back{
      position:absolute;
      top:20px; left:20px;
      color:white; text-decoration:none; font-size:16px;
    }
    #scramble{
      font-size:22px; color:#aaa;
      margin-bottom:24px;
      max-width:90vw; text-align:center;
      word-break:break-word; line-height:1.4;
    }
    twisty-player{ width:280px; height:280px; }
    #new-scramble-btn{
      margin-top:24px;
      padding:12px 28px;
      font-size:18px;
      background:#222; color:white;
      border:none; border-radius:8px;
      cursor:pointer;
    }
    #new-scramble-btn:hover{ background:#333; }
    #track{
      margin-top:16px;
      font-size:44px;
      color:#fff;
      font-weight:700;
      letter-spacing:2px;
      text-align:center;
      max-width:92vw;
      word-break:break-word;
      line-height:1.2;
    }
  </style>

  <script type="module">
    import "https://cdn.cubing.net/v0/js/cubing/twisty";
  </script>
</head>

<body>
  <h1>SCRAMBLE</h1>
  <a href="index.html" class="back">‚Üê Back to Home</a>

  <div id="scramble"></div>

  <twisty-player
    id="twisty"
    puzzle="3x3x3"
    hint-facelets="floating"
    background="none"
    control-panel="none"
  ></twisty-player>

  <div id="track"></div>

  <button id="new-scramble-btn">New Scramble</button>
<script>
  // =========================
  // DOM
  // =========================
  const $ = (id) => document.getElementById(id);

  // =========================
  // Scramble UI
  // =========================
  function generateScramble(len = 20) {
    const moves = ["R","L","U","D","F","B"];
    const modifiers = ["", "'", "2"];
    const out = [];
    let prev = "";

    while (out.length < len) {
      const move = moves[Math.floor(Math.random() * moves.length)];
      if (move === prev) continue;
      prev = move;

      const mod = modifiers[Math.floor(Math.random() * modifiers.length)];
      out.push(move + mod);
    }
    return out.join(" ");
  }

  function setScramble(scramble) {
    $("scramble").textContent = scramble;

    const twisty = $("twisty");
    twisty.setAttribute("experimental-setup-alg", scramble);
    twisty.alg = "";

    const cornerCycles = bufferMultiCyclesWithCornerCut(scramble);
    const edgeCycles   = bufferMultiCyclesEdgesWithCut(scramble);

    $("track").innerHTML = `
      <div style="font-size:32px; margin-bottom:10px;">CORNERS</div>
      <div>${renderTrackHTML(cornerCycles)}</div>
      <div style="height:18px;"></div>
      <div style="font-size:32px; margin-bottom:10px;">EDGES</div>
      <div>${renderTrackHTML(edgeCycles)}</div>
    `;
  }

  function updateScramble() {
    setScramble(generateScramble());
  }

  $("new-scramble-btn").addEventListener("click", updateScramble);
  window.addEventListener("load", updateScramble);

  // =========================
  // BLIND_SCHEME (ignore setup)
  // =========================
  const BLIND_SCHEME = {
    edges: {
      UF: { stickers: { U: { letter: "C" },   F: { letter: "I" } } },
      UR: { stickers: { U: { letter: "B" },   R: { letter: "M" } } },
      UB: { stickers: { U: { letter: "A" },   B: { letter: "Q" } } },
      UL: { stickers: { U: { letter: "D" },   L: { letter: "E" } } },
      DF: { stickers: { D: { letter: "U" },   F: { letter: "K" } } },
      DR: { stickers: { D: { letter: "V" },   R: { letter: "O" } } },
      DB: { stickers: { D: { letter: "W" },   B: { letter: "S" } } },
      DL: { stickers: { D: { letter: "X" },   L: { letter: "G" } } },
      FR: { stickers: { F: { letter: "J" },   R: { letter: "P" } } },
      BR: { stickers: { B: { letter: "T" },   R: { letter: "N" } } },
      BL: { stickers: { B: { letter: "R" },   L: { letter: "H" } } },
      FL: { stickers: { F: { letter: "L" },   L: { letter: "F" } } },
    },
    corners: {
      UFR: { stickers: { U: { letter: "C" },   F: { letter: "J" },   R: { letter: "M" } } },
      URB: { stickers: { U: { letter: "B" },   R: { letter: "N" },   B: { letter: "Q" } } },
      UBL: { stickers: { U: { letter: "A" },   B: { letter: "R" },   L: { letter: "E" } } },
      ULF: { stickers: { U: { letter: "D" },   L: { letter: "F" },   F: { letter: "I" } } },
      DFR: { stickers: { D: { letter: "V" },   F: { letter: "K" },   R: { letter: "P" } } },
      DRB: { stickers: { D: { letter: "W" },   R: { letter: "O" },   B: { letter: "T" } } },
      DBL: { stickers: { D: { letter: "X" },   B: { letter: "S" },   L: { letter: "H" } } },
      DLF: { stickers: { D: { letter: "U" },   L: { letter: "G" },   F: { letter: "L" } } },
    }
  };

  // =========================
  // Solved corner letters (54)
  // =========================
  function solvedCornerLetters54() {
    const a = Array(54).fill(".");
    a[0] = "A"; a[2] = "B"; a[8] = "C"; a[6] = "D";
    a[36] = "E"; a[38] = "F"; a[44] = "G"; a[42] = "H";
    a[18] = "I"; a[20] = "J"; a[26] = "K"; a[24] = "L";
    a[9]  = "M"; a[11] = "N"; a[17] = "O"; a[15] = "P";
    a[45] = "Q"; a[47] = "R"; a[53] = "S"; a[51] = "T";
    a[27] = "U"; a[29] = "V"; a[35] = "W"; a[33] = "X";
    return a;
  }

  // =========================
  // Solved edge letters (54)
  // NOTE: B-face left/right swapped to match your moveB orientation.
  // =========================
  function solvedEdgeLetters54() {
    const a = Array(54).fill(".");
    const U=0, R=9, F=18, D=27, L=36, B=45;

    a[U+7] = BLIND_SCHEME.edges.UF.stickers.U.letter; a[F+1] = BLIND_SCHEME.edges.UF.stickers.F.letter; // C I
    a[U+5] = BLIND_SCHEME.edges.UR.stickers.U.letter; a[R+1] = BLIND_SCHEME.edges.UR.stickers.R.letter; // B M
    a[U+1] = BLIND_SCHEME.edges.UB.stickers.U.letter; a[B+1] = BLIND_SCHEME.edges.UB.stickers.B.letter; // A Q
    a[U+3] = BLIND_SCHEME.edges.UL.stickers.U.letter; a[L+1] = BLIND_SCHEME.edges.UL.stickers.L.letter; // D E

    a[D+1] = BLIND_SCHEME.edges.DF.stickers.D.letter; a[F+7] = BLIND_SCHEME.edges.DF.stickers.F.letter; // U K
    a[D+5] = BLIND_SCHEME.edges.DR.stickers.D.letter; a[R+7] = BLIND_SCHEME.edges.DR.stickers.R.letter; // V O
    a[D+7] = BLIND_SCHEME.edges.DB.stickers.D.letter; a[B+7] = BLIND_SCHEME.edges.DB.stickers.B.letter; // W S
    a[D+3] = BLIND_SCHEME.edges.DL.stickers.D.letter; a[L+7] = BLIND_SCHEME.edges.DL.stickers.L.letter; // X G

    a[F+5] = BLIND_SCHEME.edges.FR.stickers.F.letter; a[R+3] = BLIND_SCHEME.edges.FR.stickers.R.letter; // J P
    a[B+3] = BLIND_SCHEME.edges.BR.stickers.B.letter; a[R+5] = BLIND_SCHEME.edges.BR.stickers.R.letter; // T N (swapped)
    a[B+5] = BLIND_SCHEME.edges.BL.stickers.B.letter; a[L+3] = BLIND_SCHEME.edges.BL.stickers.L.letter; // R H (swapped)
    a[F+3] = BLIND_SCHEME.edges.FL.stickers.F.letter; a[L+5] = BLIND_SCHEME.edges.FL.stickers.L.letter; // L F

    return a;
  }

  // =========================
  // Cube moves
  // =========================
  function rotateFaceCW(arr, base) {
    const i = base;
    const t0 = arr[i+0], t1 = arr[i+1], t2 = arr[i+2],
          t3 = arr[i+3],           t5 = arr[i+5],
          t6 = arr[i+6], t7 = arr[i+7], t8 = arr[i+8];

    arr[i+0] = t6; arr[i+1] = t3; arr[i+2] = t0;
    arr[i+3] = t7;              arr[i+5] = t1;
    arr[i+6] = t8; arr[i+7] = t5; arr[i+8] = t2;
  }

  function moveU(a){
    rotateFaceCW(a, 0);
    const F=18, R=9, B=45, L=36;
    const t = [a[F+0],a[F+1],a[F+2]];
    [a[F+0],a[F+1],a[F+2]] = [a[R+0],a[R+1],a[R+2]];
    [a[R+0],a[R+1],a[R+2]] = [a[B+0],a[B+1],a[B+2]];
    [a[B+0],a[B+1],a[B+2]] = [a[L+0],a[L+1],a[L+2]];
    [a[L+0],a[L+1],a[L+2]] = t;
  }

  function moveD(a){
    rotateFaceCW(a, 27);
    const F=18, R=9, B=45, L=36;
    const t = [a[F+6],a[F+7],a[F+8]];
    [a[F+6],a[F+7],a[F+8]] = [a[L+6],a[L+7],a[L+8]];
    [a[L+6],a[L+7],a[L+8]] = [a[B+6],a[B+7],a[B+8]];
    [a[B+6],a[B+7],a[B+8]] = [a[R+6],a[R+7],a[R+8]];
    [a[R+6],a[R+7],a[R+8]] = t;
  }

  function moveR(a){
    rotateFaceCW(a, 9);
    const U=0, F=18, D=27, B=45;
    const t = [a[U+2],a[U+5],a[U+8]];
    [a[U+2],a[U+5],a[U+8]] = [a[F+2],a[F+5],a[F+8]];
    [a[F+2],a[F+5],a[F+8]] = [a[D+2],a[D+5],a[D+8]];
    [a[D+2],a[D+5],a[D+8]] = [a[B+6],a[B+3],a[B+0]];
    [a[B+6],a[B+3],a[B+0]] = t;
  }

  function moveL(a){
    rotateFaceCW(a, 36);
    const U=0, F=18, D=27, B=45;
    const t = [a[U+0],a[U+3],a[U+6]];
    [a[U+0],a[U+3],a[U+6]] = [a[B+8],a[B+5],a[B+2]];
    [a[B+8],a[B+5],a[B+2]] = [a[D+0],a[D+3],a[D+6]];
    [a[D+0],a[D+3],a[D+6]] = [a[F+0],a[F+3],a[F+6]];
    [a[F+0],a[F+3],a[F+6]] = t;
  }

  function moveF(a){
    rotateFaceCW(a, 18);
    const U=0, R=9, D=27, L=36;
    const t = [a[U+6],a[U+7],a[U+8]];
    [a[U+6],a[U+7],a[U+8]] = [a[L+8],a[L+5],a[L+2]];
    [a[L+8],a[L+5],a[L+2]] = [a[D+2],a[D+1],a[D+0]];
    [a[D+2],a[D+1],a[D+0]] = [a[R+0],a[R+3],a[R+6]];
    [a[R+0],a[R+3],a[R+6]] = t;
  }

  function moveB(a){
    rotateFaceCW(a, 45);
    const U=0, R=9, D=27, L=36;
    const t = [a[U+0],a[U+1],a[U+2]];
    [a[U+0],a[U+1],a[U+2]] = [a[R+2],a[R+5],a[R+8]];
    [a[R+2],a[R+5],a[R+8]] = [a[D+8],a[D+7],a[D+6]];
    [a[D+8],a[D+7],a[D+6]] = [a[L+6],a[L+3],a[L+0]];
    [a[L+6],a[L+3],a[L+0]] = t;
  }

  function applyMove(a, face){
    switch(face){
      case "U": return moveU(a);
      case "D": return moveD(a);
      case "R": return moveR(a);
      case "L": return moveL(a);
      case "F": return moveF(a);
      case "B": return moveB(a);
    }
  }

  function applyAlg(a, algStr){
    const tokens = algStr.trim().split(/\s+/).filter(Boolean);
    for (const tok of tokens){
      const face = tok[0];
      const suffix = tok.slice(1);

      let times = 1;
      if (suffix === "2") times = 2;
      else if (suffix === "'") times = 3;

      for (let i=0; i<times; i++) applyMove(a, face);
    }
  }

  // =========================
  // Track renderer
  // =========================
  function renderTrackHTML(cycles) {
    const colors = [
      "#ffd166", "#06d6a0", "#4cc9f0", "#f72585",
      "#b8f2e6", "#fca311", "#a78bfa", "#80ed99",
    ];

    const flat = [];
    cycles.forEach((letters, ci) => {
      letters.forEach(ch => flat.push({ ch, ci }));
    });

    const pairHtml = [];
    for (let i = 0; i < flat.length; i += 2) {
      const a = flat[i];
      const b = flat[i + 1];

      const aHtml = `<span style="color:${colors[a.ci % colors.length]}">${a.ch}</span>`;
      const bHtml = b ? `<span style="color:${colors[b.ci % colors.length]}">${b.ch}</span>` : "";
      pairHtml.push(aHtml + bHtml);
    }
    return pairHtml.join(" ");
  }

  // =========================
  // CORNERS multi-cycle (with buffer piece pre-visited)
  // =========================
  function bufferMultiCyclesWithCornerCut(scramble){
    const solved = solvedCornerLetters54();
    const cur = solvedCornerLetters54();
    applyAlg(cur, scramble);

    const STOP = new Set(["A","R","E"]);
    const CORNERS = [
      ["A","E","R"], // UBL
      ["B","N","Q"], // URB
      ["C","J","M"], // UFR
      ["D","F","I"], // ULF
      ["U","L","G"], // DLF
      ["V","K","P"], // DFR
      ["W","O","T"], // DRB
      ["X","H","S"], // DBL
    ];
    const cornerOf = new Map();
    CORNERS.forEach((grp, i) => grp.forEach(ch => cornerOf.set(ch, i)));

    const idxOf = (letter) => solved.indexOf(letter);
    const cornerId = (letter) => cornerOf.get(letter);
    const posLetters = solved.filter(x => x !== ".");

    const visitedCornerGlobal = new Set();
    const processedStartCorners = new Set();

    const bufferCornerId = cornerId("E");
    if (bufferCornerId !== undefined) {
      visitedCornerGlobal.add(bufferCornerId);
      processedStartCorners.add(bufferCornerId);
    }

    function markGlobal(letter){
      if (STOP.has(letter)) return;
      const cid = cornerId(letter);
      if (cid !== undefined) visitedCornerGlobal.add(cid);
    }

    function runFromEUntilARE(){
      let p = "E";
      const out = [];
      const cycleVisited = new Set();

      for (let step = 0; step < 80; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (STOP.has(s)) break;

        const cidS = cornerId(s);
        if (cidS !== undefined && cycleVisited.has(cidS)) break;

        out.push(s);
        if (cidS !== undefined) cycleVisited.add(cidS);
        markGlobal(s);
        p = s;
      }
      return out;
    }

    function runCycleFrom(start){
      let p = start;
      const startCid = cornerId(start);

      const out = [start];
      const cycleVisited = new Set();

      for (let step = 0; step < 120; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (s === start && out.length === 1) return [];
        if (STOP.has(s)) break;

        const cidS = cornerId(s);
        if (cidS !== undefined && cycleVisited.has(cidS)) break;

        if (cidS !== undefined && cidS === startCid && out.length > 1) {
          out.push(s);
          markGlobal(s);
          break;
        }

        out.push(s);
        if (cidS !== undefined) cycleVisited.add(cidS);
        markGlobal(s);
        p = s;
      }
      return (out.length > 1) ? out : [];
    }

    const cycles = [];
    const first = runFromEUntilARE();
    if (first.length) cycles.push(first);

    while (true){
      let nextStart = null;

      for (const p of posLetters){
        if (STOP.has(p)) continue;
        const cid = cornerId(p);
        if (cid === undefined) continue;
        if (processedStartCorners.has(cid)) continue;
        if (visitedCornerGlobal.has(cid)) continue;
        nextStart = p; break;
      }

      if (!nextStart) break;

      const cid = cornerId(nextStart);
      if (cid !== undefined) processedStartCorners.add(cid);

      const c = runCycleFrom(nextStart);
      if (c.length) cycles.push(c);
      if (cycles.length > 30) break;
    }

    return cycles;
  }

  // =========================
  // EDGES multi-cycle:
  // - Do not show U/K (buffer piece)
  // - New cycle start priority: A highest
  // - Q, CI, WS lowest (Q piece + CI + WS)
  // =========================
  function bufferMultiCyclesEdgesWithCut(scramble){
    const solved = solvedEdgeLetters54();
    const cur = solvedEdgeLetters54();
    applyAlg(cur, scramble);

    const EDGES = [
      ["C","I"], // UF
      ["B","M"], // UR
      ["A","Q"], // UB
      ["D","E"], // UL
      ["U","K"], // DF buffer piece
      ["V","O"], // DR
      ["W","S"], // DB
      ["X","G"], // DL
      ["J","P"], // FR
      ["T","N"], // BR
      ["R","H"], // BL
      ["L","F"], // FL
    ];

    const edgeOf = new Map();
    EDGES.forEach((grp, i) => grp.forEach(ch => edgeOf.set(ch, i)));

    const idxOf  = (letter) => solved.indexOf(letter);
    const edgeId = (letter) => edgeOf.get(letter);
    const posLetters = solved.filter(x => x !== ".");

    const BUFFER = BLIND_SCHEME.edges.DF.stickers.D.letter; // "U"
    const bufferEid = edgeId(BUFFER);

    const otherOnSameEdge = (letter) => {
      const eid = edgeId(letter);
      if (eid === undefined) return null;
      const pair = EDGES[eid];
      return (pair[0] === letter) ? pair[1] : pair[0];
    };
    const BUFFER_MATE = otherOnSameEdge(BUFFER); // "K"

    // STOP includes both U and K
    const STOP = new Set([BUFFER]);
    if (BUFFER_MATE) STOP.add(BUFFER_MATE);

    // Low priority: Q piece (i.e. AQ but A itself is allowed), plus CI and WS
    // => treat Q, C, I, W, S as low-priority triggers (but NOT A).
    const lowPriorityLetters = ["Q","C","I","W","S"];
    const lowPriorityEdgeIds = new Set(
      lowPriorityLetters.map(ch => edgeId(ch)).filter(eid => eid !== undefined)
    );

    const visitedEdgeGlobal = new Set();
    const processedStartEdges = new Set();

    // Mark buffer piece visited/processed
    if (bufferEid !== undefined) {
      visitedEdgeGlobal.add(bufferEid);
      processedStartEdges.add(bufferEid);
    }

    function markGlobal(letter){
      if (STOP.has(letter)) return;
      const eid = edgeId(letter);
      if (eid !== undefined) visitedEdgeGlobal.add(eid);
    }

    function runFromBufferUntilStop(){
      let p = BUFFER;
      const out = [];
      const cycleVisited = new Set();

      for (let step = 0; step < 80; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (STOP.has(s)) break;

        const eidS = edgeId(s);
        if (eidS !== undefined && cycleVisited.has(eidS)) break;

        out.push(s);
        if (eidS !== undefined) cycleVisited.add(eidS);
        markGlobal(s);
        p = s;
      }
      return out;
    }

    function runCycleFrom(start){
      let p = start;
      const startEid = edgeId(start);

      const out = [start];
      const cycleVisited = new Set();

      for (let step = 0; step < 120; step++){
        const idx = idxOf(p);
        if (idx < 0) break;

        const s = cur[idx];
        if (s === start && out.length === 1) return [];
        if (STOP.has(s)) break;

        const eidS = edgeId(s);
        if (eidS !== undefined && cycleVisited.has(eidS)) break;

        if (eidS !== undefined && eidS === startEid && out.length > 1) {
          out.push(s);
          markGlobal(s);
          break;
        }

        out.push(s);
        if (eidS !== undefined) cycleVisited.add(eidS);
        markGlobal(s);
        p = s;
      }
      return (out.length > 1) ? out : [];
    }

    // Pick next start:
    // 0) If 'A' is eligible, always pick it first
    // 1) Otherwise pick eligible non-low-priority
    // 2) Finally allow low-priority
    function isEligibleStart(p){
      if (STOP.has(p)) return false;
      const eid = edgeId(p);
      if (eid === undefined) return false;
      if (processedStartEdges.has(eid)) return false;
      if (visitedEdgeGlobal.has(eid)) return false;
      return true;
    }

    function pickNextStart(){
      // 0) A highest priority
      if (isEligibleStart("A")) return "A";

      // 1) Avoid low priority pieces
      for (const p of posLetters){
        if (!isEligibleStart(p)) continue;
        const eid = edgeId(p);
        if (lowPriorityEdgeIds.has(eid)) continue;
        return p;
      }

      // 2) Allow low priority pieces
      for (const p of posLetters){
        if (!isEligibleStart(p)) continue;
        return p;
      }

      return null;
    }

    const cycles = [];
    const first = runFromBufferUntilStop();
    if (first.length) cycles.push(first);

    while (true){
      const nextStart = pickNextStart();
      if (!nextStart) break;

      const eid = edgeId(nextStart);
      if (eid !== undefined) processedStartEdges.add(eid);

      const c = runCycleFrom(nextStart);
      if (c.length) cycles.push(c);

      if (cycles.length > 30) break;
    }

    return cycles;
  }
</script>


</body>
</html>
